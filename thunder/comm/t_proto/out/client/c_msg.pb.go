// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: c_msg.proto

package pb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Heartbeat struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Heartbeat) Reset()         { *m = Heartbeat{} }
func (m *Heartbeat) String() string { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()    {}
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{0}
}
func (m *Heartbeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Heartbeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Heartbeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Heartbeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Heartbeat.Merge(m, src)
}
func (m *Heartbeat) XXX_Size() int {
	return m.Size()
}
func (m *Heartbeat) XXX_DiscardUnknown() {
	xxx_messageInfo_Heartbeat.DiscardUnknown(m)
}

var xxx_messageInfo_Heartbeat proto.InternalMessageInfo

type KickNtf struct {
	ErrNo                int32    `protobuf:"varint,1,opt,name=errNo,proto3" json:"errNo,omitempty"`
	ErrMsg               string   `protobuf:"bytes,2,opt,name=errMsg,proto3" json:"errMsg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KickNtf) Reset()         { *m = KickNtf{} }
func (m *KickNtf) String() string { return proto.CompactTextString(m) }
func (*KickNtf) ProtoMessage()    {}
func (*KickNtf) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{1}
}
func (m *KickNtf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KickNtf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KickNtf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KickNtf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KickNtf.Merge(m, src)
}
func (m *KickNtf) XXX_Size() int {
	return m.Size()
}
func (m *KickNtf) XXX_DiscardUnknown() {
	xxx_messageInfo_KickNtf.DiscardUnknown(m)
}

var xxx_messageInfo_KickNtf proto.InternalMessageInfo

func (m *KickNtf) GetErrNo() int32 {
	if m != nil {
		return m.ErrNo
	}
	return 0
}

func (m *KickNtf) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

// 错误消息 所有通信功能有错误就会返回此消息
type ErrNtf struct {
	ErrNo                int32    `protobuf:"varint,1,opt,name=errNo,proto3" json:"errNo,omitempty"`
	ErrMsg               string   `protobuf:"bytes,2,opt,name=errMsg,proto3" json:"errMsg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ErrNtf) Reset()         { *m = ErrNtf{} }
func (m *ErrNtf) String() string { return proto.CompactTextString(m) }
func (*ErrNtf) ProtoMessage()    {}
func (*ErrNtf) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{2}
}
func (m *ErrNtf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrNtf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrNtf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrNtf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrNtf.Merge(m, src)
}
func (m *ErrNtf) XXX_Size() int {
	return m.Size()
}
func (m *ErrNtf) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrNtf.DiscardUnknown(m)
}

var xxx_messageInfo_ErrNtf proto.InternalMessageInfo

func (m *ErrNtf) GetErrNo() int32 {
	if m != nil {
		return m.ErrNo
	}
	return 0
}

func (m *ErrNtf) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

type GmReq struct {
	GmType               GmType   `protobuf:"varint,1,opt,name=gmType,proto3,enum=GmType" json:"gmType,omitempty"`
	Data                 string   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GmReq) Reset()         { *m = GmReq{} }
func (m *GmReq) String() string { return proto.CompactTextString(m) }
func (*GmReq) ProtoMessage()    {}
func (*GmReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{3}
}
func (m *GmReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GmReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GmReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GmReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GmReq.Merge(m, src)
}
func (m *GmReq) XXX_Size() int {
	return m.Size()
}
func (m *GmReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GmReq.DiscardUnknown(m)
}

var xxx_messageInfo_GmReq proto.InternalMessageInfo

func (m *GmReq) GetGmType() GmType {
	if m != nil {
		return m.GmType
	}
	return GmType_Set_Gold
}

func (m *GmReq) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type GmAck struct {
	GmType               GmType   `protobuf:"varint,1,opt,name=gmType,proto3,enum=GmType" json:"gmType,omitempty"`
	Data                 string   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GmAck) Reset()         { *m = GmAck{} }
func (m *GmAck) String() string { return proto.CompactTextString(m) }
func (*GmAck) ProtoMessage()    {}
func (*GmAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{4}
}
func (m *GmAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GmAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GmAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GmAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GmAck.Merge(m, src)
}
func (m *GmAck) XXX_Size() int {
	return m.Size()
}
func (m *GmAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GmAck.DiscardUnknown(m)
}

var xxx_messageInfo_GmAck proto.InternalMessageInfo

func (m *GmAck) GetGmType() GmType {
	if m != nil {
		return m.GmType
	}
	return GmType_Set_Gold
}

func (m *GmAck) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type TestMsg struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestMsg) Reset()         { *m = TestMsg{} }
func (m *TestMsg) String() string { return proto.CompactTextString(m) }
func (*TestMsg) ProtoMessage()    {}
func (*TestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{5}
}
func (m *TestMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestMsg.Merge(m, src)
}
func (m *TestMsg) XXX_Size() int {
	return m.Size()
}
func (m *TestMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_TestMsg.DiscardUnknown(m)
}

var xxx_messageInfo_TestMsg proto.InternalMessageInfo

type LoginReq struct {
	Type                 LoginType `protobuf:"varint,1,opt,name=type,proto3,enum=LoginType" json:"type,omitempty"`
	InitData             string    `protobuf:"bytes,2,opt,name=initData,proto3" json:"initData,omitempty"`
	Invite               uint64    `protobuf:"varint,3,opt,name=invite,proto3" json:"invite,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LoginReq) Reset()         { *m = LoginReq{} }
func (m *LoginReq) String() string { return proto.CompactTextString(m) }
func (*LoginReq) ProtoMessage()    {}
func (*LoginReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{6}
}
func (m *LoginReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginReq.Merge(m, src)
}
func (m *LoginReq) XXX_Size() int {
	return m.Size()
}
func (m *LoginReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginReq.DiscardUnknown(m)
}

var xxx_messageInfo_LoginReq proto.InternalMessageInfo

func (m *LoginReq) GetType() LoginType {
	if m != nil {
		return m.Type
	}
	return LoginType_password
}

func (m *LoginReq) GetInitData() string {
	if m != nil {
		return m.InitData
	}
	return ""
}

func (m *LoginReq) GetInvite() uint64 {
	if m != nil {
		return m.Invite
	}
	return 0
}

type LoginAck struct {
	UserID               uint64   `protobuf:"varint,1,opt,name=userID,proto3" json:"userID,omitempty"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	LinkAddr             string   `protobuf:"bytes,3,opt,name=linkAddr,proto3" json:"linkAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoginAck) Reset()         { *m = LoginAck{} }
func (m *LoginAck) String() string { return proto.CompactTextString(m) }
func (*LoginAck) ProtoMessage()    {}
func (*LoginAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{7}
}
func (m *LoginAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginAck.Merge(m, src)
}
func (m *LoginAck) XXX_Size() int {
	return m.Size()
}
func (m *LoginAck) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginAck.DiscardUnknown(m)
}

var xxx_messageInfo_LoginAck proto.InternalMessageInfo

func (m *LoginAck) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *LoginAck) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *LoginAck) GetLinkAddr() string {
	if m != nil {
		return m.LinkAddr
	}
	return ""
}

type VerifyReq struct {
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyReq) Reset()         { *m = VerifyReq{} }
func (m *VerifyReq) String() string { return proto.CompactTextString(m) }
func (*VerifyReq) ProtoMessage()    {}
func (*VerifyReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{8}
}
func (m *VerifyReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyReq.Merge(m, src)
}
func (m *VerifyReq) XXX_Size() int {
	return m.Size()
}
func (m *VerifyReq) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyReq.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyReq proto.InternalMessageInfo

func (m *VerifyReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type VerifyAck struct {
	ErrNo                int32    `protobuf:"varint,1,opt,name=errNo,proto3" json:"errNo,omitempty"`
	ErrMsg               string   `protobuf:"bytes,2,opt,name=errMsg,proto3" json:"errMsg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyAck) Reset()         { *m = VerifyAck{} }
func (m *VerifyAck) String() string { return proto.CompactTextString(m) }
func (*VerifyAck) ProtoMessage()    {}
func (*VerifyAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{9}
}
func (m *VerifyAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyAck.Merge(m, src)
}
func (m *VerifyAck) XXX_Size() int {
	return m.Size()
}
func (m *VerifyAck) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyAck.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyAck proto.InternalMessageInfo

func (m *VerifyAck) GetErrNo() int32 {
	if m != nil {
		return m.ErrNo
	}
	return 0
}

func (m *VerifyAck) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

type ReconnectReq struct {
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReconnectReq) Reset()         { *m = ReconnectReq{} }
func (m *ReconnectReq) String() string { return proto.CompactTextString(m) }
func (*ReconnectReq) ProtoMessage()    {}
func (*ReconnectReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{10}
}
func (m *ReconnectReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReconnectReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReconnectReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReconnectReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReconnectReq.Merge(m, src)
}
func (m *ReconnectReq) XXX_Size() int {
	return m.Size()
}
func (m *ReconnectReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReconnectReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReconnectReq proto.InternalMessageInfo

func (m *ReconnectReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type ReconnectAck struct {
	ErrNo                int32    `protobuf:"varint,1,opt,name=errNo,proto3" json:"errNo,omitempty"`
	ErrMsg               string   `protobuf:"bytes,2,opt,name=errMsg,proto3" json:"errMsg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReconnectAck) Reset()         { *m = ReconnectAck{} }
func (m *ReconnectAck) String() string { return proto.CompactTextString(m) }
func (*ReconnectAck) ProtoMessage()    {}
func (*ReconnectAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{11}
}
func (m *ReconnectAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReconnectAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReconnectAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReconnectAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReconnectAck.Merge(m, src)
}
func (m *ReconnectAck) XXX_Size() int {
	return m.Size()
}
func (m *ReconnectAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ReconnectAck.DiscardUnknown(m)
}

var xxx_messageInfo_ReconnectAck proto.InternalMessageInfo

func (m *ReconnectAck) GetErrNo() int32 {
	if m != nil {
		return m.ErrNo
	}
	return 0
}

func (m *ReconnectAck) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

type MapUnit struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	X                    int32    `protobuf:"varint,2,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"varint,3,opt,name=y,proto3" json:"y,omitempty"`
	Thunder              int32    `protobuf:"varint,4,opt,name=thunder,proto3" json:"thunder,omitempty"`
	TileType             TileType `protobuf:"varint,5,opt,name=tileType,proto3,enum=TileType" json:"tileType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MapUnit) Reset()         { *m = MapUnit{} }
func (m *MapUnit) String() string { return proto.CompactTextString(m) }
func (*MapUnit) ProtoMessage()    {}
func (*MapUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{12}
}
func (m *MapUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MapUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MapUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MapUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapUnit.Merge(m, src)
}
func (m *MapUnit) XXX_Size() int {
	return m.Size()
}
func (m *MapUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_MapUnit.DiscardUnknown(m)
}

var xxx_messageInfo_MapUnit proto.InternalMessageInfo

func (m *MapUnit) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MapUnit) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *MapUnit) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *MapUnit) GetThunder() int32 {
	if m != nil {
		return m.Thunder
	}
	return 0
}

func (m *MapUnit) GetTileType() TileType {
	if m != nil {
		return m.TileType
	}
	return TileType_Empty
}

type Maps struct {
	BirthX               int32      `protobuf:"varint,1,opt,name=birthX,proto3" json:"birthX,omitempty"`
	BirthY               int32      `protobuf:"varint,2,opt,name=birthY,proto3" json:"birthY,omitempty"`
	Treasure             int32      `protobuf:"varint,3,opt,name=treasure,proto3" json:"treasure,omitempty"`
	NowX                 int32      `protobuf:"varint,4,opt,name=nowX,proto3" json:"nowX,omitempty"`
	NowY                 int32      `protobuf:"varint,5,opt,name=nowY,proto3" json:"nowY,omitempty"`
	Grids                []*MapUnit `protobuf:"bytes,6,rep,name=grids,proto3" json:"grids,omitempty"`
	ReTreasure           int32      `protobuf:"varint,7,opt,name=reTreasure,proto3" json:"reTreasure,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Maps) Reset()         { *m = Maps{} }
func (m *Maps) String() string { return proto.CompactTextString(m) }
func (*Maps) ProtoMessage()    {}
func (*Maps) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{13}
}
func (m *Maps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Maps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Maps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Maps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Maps.Merge(m, src)
}
func (m *Maps) XXX_Size() int {
	return m.Size()
}
func (m *Maps) XXX_DiscardUnknown() {
	xxx_messageInfo_Maps.DiscardUnknown(m)
}

var xxx_messageInfo_Maps proto.InternalMessageInfo

func (m *Maps) GetBirthX() int32 {
	if m != nil {
		return m.BirthX
	}
	return 0
}

func (m *Maps) GetBirthY() int32 {
	if m != nil {
		return m.BirthY
	}
	return 0
}

func (m *Maps) GetTreasure() int32 {
	if m != nil {
		return m.Treasure
	}
	return 0
}

func (m *Maps) GetNowX() int32 {
	if m != nil {
		return m.NowX
	}
	return 0
}

func (m *Maps) GetNowY() int32 {
	if m != nil {
		return m.NowY
	}
	return 0
}

func (m *Maps) GetGrids() []*MapUnit {
	if m != nil {
		return m.Grids
	}
	return nil
}

func (m *Maps) GetReTreasure() int32 {
	if m != nil {
		return m.ReTreasure
	}
	return 0
}

type EnterReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnterReq) Reset()         { *m = EnterReq{} }
func (m *EnterReq) String() string { return proto.CompactTextString(m) }
func (*EnterReq) ProtoMessage()    {}
func (*EnterReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{14}
}
func (m *EnterReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnterReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnterReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnterReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnterReq.Merge(m, src)
}
func (m *EnterReq) XXX_Size() int {
	return m.Size()
}
func (m *EnterReq) XXX_DiscardUnknown() {
	xxx_messageInfo_EnterReq.DiscardUnknown(m)
}

var xxx_messageInfo_EnterReq proto.InternalMessageInfo

type EnterNtf struct {
	Lv                   int32           `protobuf:"varint,1,opt,name=lv,proto3" json:"lv,omitempty"`
	Gold                 float64         `protobuf:"fixed64,2,opt,name=gold,proto3" json:"gold,omitempty"`
	Maps                 *Maps           `protobuf:"bytes,3,opt,name=maps,proto3" json:"maps,omitempty"`
	Strength             int32           `protobuf:"varint,4,opt,name=strength,proto3" json:"strength,omitempty"`
	Dead                 bool            `protobuf:"varint,5,opt,name=dead,proto3" json:"dead,omitempty"`
	FreeResetMap         bool            `protobuf:"varint,6,opt,name=freeResetMap,proto3" json:"freeResetMap,omitempty"`
	Head                 string          `protobuf:"bytes,7,opt,name=head,proto3" json:"head,omitempty"`
	Diamond              int32           `protobuf:"varint,8,opt,name=diamond,proto3" json:"diamond,omitempty"`
	Shop                 []*ShopUnit     `protobuf:"bytes,9,rep,name=shop,proto3" json:"shop,omitempty"`
	ExtraStrength        int32           `protobuf:"varint,10,opt,name=extra_strength,json=extraStrength,proto3" json:"extra_strength,omitempty"`
	Hasten               *Hasten         `protobuf:"bytes,11,opt,name=hasten,proto3" json:"hasten,omitempty"`
	RedPoint             []*RedPointUnit `protobuf:"bytes,12,rep,name=redPoint,proto3" json:"redPoint,omitempty"`
	GuildId              uint64          `protobuf:"varint,13,opt,name=guildId,proto3" json:"guildId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *EnterNtf) Reset()         { *m = EnterNtf{} }
func (m *EnterNtf) String() string { return proto.CompactTextString(m) }
func (*EnterNtf) ProtoMessage()    {}
func (*EnterNtf) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{15}
}
func (m *EnterNtf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnterNtf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnterNtf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnterNtf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnterNtf.Merge(m, src)
}
func (m *EnterNtf) XXX_Size() int {
	return m.Size()
}
func (m *EnterNtf) XXX_DiscardUnknown() {
	xxx_messageInfo_EnterNtf.DiscardUnknown(m)
}

var xxx_messageInfo_EnterNtf proto.InternalMessageInfo

func (m *EnterNtf) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *EnterNtf) GetGold() float64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *EnterNtf) GetMaps() *Maps {
	if m != nil {
		return m.Maps
	}
	return nil
}

func (m *EnterNtf) GetStrength() int32 {
	if m != nil {
		return m.Strength
	}
	return 0
}

func (m *EnterNtf) GetDead() bool {
	if m != nil {
		return m.Dead
	}
	return false
}

func (m *EnterNtf) GetFreeResetMap() bool {
	if m != nil {
		return m.FreeResetMap
	}
	return false
}

func (m *EnterNtf) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *EnterNtf) GetDiamond() int32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *EnterNtf) GetShop() []*ShopUnit {
	if m != nil {
		return m.Shop
	}
	return nil
}

func (m *EnterNtf) GetExtraStrength() int32 {
	if m != nil {
		return m.ExtraStrength
	}
	return 0
}

func (m *EnterNtf) GetHasten() *Hasten {
	if m != nil {
		return m.Hasten
	}
	return nil
}

func (m *EnterNtf) GetRedPoint() []*RedPointUnit {
	if m != nil {
		return m.RedPoint
	}
	return nil
}

func (m *EnterNtf) GetGuildId() uint64 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

type MoveReq struct {
	X                    int32    `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MoveReq) Reset()         { *m = MoveReq{} }
func (m *MoveReq) String() string { return proto.CompactTextString(m) }
func (*MoveReq) ProtoMessage()    {}
func (*MoveReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{16}
}
func (m *MoveReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoveReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoveReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoveReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoveReq.Merge(m, src)
}
func (m *MoveReq) XXX_Size() int {
	return m.Size()
}
func (m *MoveReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MoveReq.DiscardUnknown(m)
}

var xxx_messageInfo_MoveReq proto.InternalMessageInfo

func (m *MoveReq) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *MoveReq) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type MoveAck struct {
	X                    int32    `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MoveAck) Reset()         { *m = MoveAck{} }
func (m *MoveAck) String() string { return proto.CompactTextString(m) }
func (*MoveAck) ProtoMessage()    {}
func (*MoveAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{17}
}
func (m *MoveAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoveAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoveAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoveAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoveAck.Merge(m, src)
}
func (m *MoveAck) XXX_Size() int {
	return m.Size()
}
func (m *MoveAck) XXX_DiscardUnknown() {
	xxx_messageInfo_MoveAck.DiscardUnknown(m)
}

var xxx_messageInfo_MoveAck proto.InternalMessageInfo

func (m *MoveAck) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *MoveAck) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type OpenWallReq struct {
	X                    int32    `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenWallReq) Reset()         { *m = OpenWallReq{} }
func (m *OpenWallReq) String() string { return proto.CompactTextString(m) }
func (*OpenWallReq) ProtoMessage()    {}
func (*OpenWallReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{18}
}
func (m *OpenWallReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenWallReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenWallReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenWallReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenWallReq.Merge(m, src)
}
func (m *OpenWallReq) XXX_Size() int {
	return m.Size()
}
func (m *OpenWallReq) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenWallReq.DiscardUnknown(m)
}

var xxx_messageInfo_OpenWallReq proto.InternalMessageInfo

func (m *OpenWallReq) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *OpenWallReq) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type OpenWallAck struct {
	Strength             int32      `protobuf:"varint,1,opt,name=strength,proto3" json:"strength,omitempty"`
	Gold                 float64    `protobuf:"fixed64,2,opt,name=gold,proto3" json:"gold,omitempty"`
	Dead                 bool       `protobuf:"varint,3,opt,name=dead,proto3" json:"dead,omitempty"`
	Grids                []*MapUnit `protobuf:"bytes,4,rep,name=grids,proto3" json:"grids,omitempty"`
	IsOver               bool       `protobuf:"varint,5,opt,name=isOver,proto3" json:"isOver,omitempty"`
	ExtraStrength        int32      `protobuf:"varint,6,opt,name=extra_strength,json=extraStrength,proto3" json:"extra_strength,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *OpenWallAck) Reset()         { *m = OpenWallAck{} }
func (m *OpenWallAck) String() string { return proto.CompactTextString(m) }
func (*OpenWallAck) ProtoMessage()    {}
func (*OpenWallAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{19}
}
func (m *OpenWallAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenWallAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenWallAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenWallAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenWallAck.Merge(m, src)
}
func (m *OpenWallAck) XXX_Size() int {
	return m.Size()
}
func (m *OpenWallAck) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenWallAck.DiscardUnknown(m)
}

var xxx_messageInfo_OpenWallAck proto.InternalMessageInfo

func (m *OpenWallAck) GetStrength() int32 {
	if m != nil {
		return m.Strength
	}
	return 0
}

func (m *OpenWallAck) GetGold() float64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *OpenWallAck) GetDead() bool {
	if m != nil {
		return m.Dead
	}
	return false
}

func (m *OpenWallAck) GetGrids() []*MapUnit {
	if m != nil {
		return m.Grids
	}
	return nil
}

func (m *OpenWallAck) GetIsOver() bool {
	if m != nil {
		return m.IsOver
	}
	return false
}

func (m *OpenWallAck) GetExtraStrength() int32 {
	if m != nil {
		return m.ExtraStrength
	}
	return 0
}

type GetTreasureReq struct {
	X                    int32    `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTreasureReq) Reset()         { *m = GetTreasureReq{} }
func (m *GetTreasureReq) String() string { return proto.CompactTextString(m) }
func (*GetTreasureReq) ProtoMessage()    {}
func (*GetTreasureReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{20}
}
func (m *GetTreasureReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTreasureReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTreasureReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTreasureReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTreasureReq.Merge(m, src)
}
func (m *GetTreasureReq) XXX_Size() int {
	return m.Size()
}
func (m *GetTreasureReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTreasureReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetTreasureReq proto.InternalMessageInfo

func (m *GetTreasureReq) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *GetTreasureReq) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type GetTreasureAck struct {
	Gold                 float64  `protobuf:"fixed64,1,opt,name=gold,proto3" json:"gold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTreasureAck) Reset()         { *m = GetTreasureAck{} }
func (m *GetTreasureAck) String() string { return proto.CompactTextString(m) }
func (*GetTreasureAck) ProtoMessage()    {}
func (*GetTreasureAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{21}
}
func (m *GetTreasureAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTreasureAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTreasureAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTreasureAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTreasureAck.Merge(m, src)
}
func (m *GetTreasureAck) XXX_Size() int {
	return m.Size()
}
func (m *GetTreasureAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTreasureAck.DiscardUnknown(m)
}

var xxx_messageInfo_GetTreasureAck proto.InternalMessageInfo

func (m *GetTreasureAck) GetGold() float64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

type OpenTreasureReq struct {
	X                    int32    `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    int32    `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenTreasureReq) Reset()         { *m = OpenTreasureReq{} }
func (m *OpenTreasureReq) String() string { return proto.CompactTextString(m) }
func (*OpenTreasureReq) ProtoMessage()    {}
func (*OpenTreasureReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{22}
}
func (m *OpenTreasureReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenTreasureReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenTreasureReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenTreasureReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenTreasureReq.Merge(m, src)
}
func (m *OpenTreasureReq) XXX_Size() int {
	return m.Size()
}
func (m *OpenTreasureReq) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenTreasureReq.DiscardUnknown(m)
}

var xxx_messageInfo_OpenTreasureReq proto.InternalMessageInfo

func (m *OpenTreasureReq) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *OpenTreasureReq) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type OpenTreasureAck struct {
	Gold                 float64  `protobuf:"fixed64,1,opt,name=gold,proto3" json:"gold,omitempty"`
	Grid                 *MapUnit `protobuf:"bytes,2,opt,name=grid,proto3" json:"grid,omitempty"`
	Treasure             int32    `protobuf:"varint,3,opt,name=treasure,proto3" json:"treasure,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenTreasureAck) Reset()         { *m = OpenTreasureAck{} }
func (m *OpenTreasureAck) String() string { return proto.CompactTextString(m) }
func (*OpenTreasureAck) ProtoMessage()    {}
func (*OpenTreasureAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{23}
}
func (m *OpenTreasureAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenTreasureAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenTreasureAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenTreasureAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenTreasureAck.Merge(m, src)
}
func (m *OpenTreasureAck) XXX_Size() int {
	return m.Size()
}
func (m *OpenTreasureAck) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenTreasureAck.DiscardUnknown(m)
}

var xxx_messageInfo_OpenTreasureAck proto.InternalMessageInfo

func (m *OpenTreasureAck) GetGold() float64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *OpenTreasureAck) GetGrid() *MapUnit {
	if m != nil {
		return m.Grid
	}
	return nil
}

func (m *OpenTreasureAck) GetTreasure() int32 {
	if m != nil {
		return m.Treasure
	}
	return 0
}

type ReviveReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReviveReq) Reset()         { *m = ReviveReq{} }
func (m *ReviveReq) String() string { return proto.CompactTextString(m) }
func (*ReviveReq) ProtoMessage()    {}
func (*ReviveReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{24}
}
func (m *ReviveReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReviveReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReviveReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReviveReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReviveReq.Merge(m, src)
}
func (m *ReviveReq) XXX_Size() int {
	return m.Size()
}
func (m *ReviveReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReviveReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReviveReq proto.InternalMessageInfo

type ReviveAck struct {
	Dead                 bool       `protobuf:"varint,1,opt,name=dead,proto3" json:"dead,omitempty"`
	Strength             int32      `protobuf:"varint,2,opt,name=strength,proto3" json:"strength,omitempty"`
	Grid                 *MapUnit   `protobuf:"bytes,3,opt,name=grid,proto3" json:"grid,omitempty"`
	NowX                 int32      `protobuf:"varint,4,opt,name=nowX,proto3" json:"nowX,omitempty"`
	NowY                 int32      `protobuf:"varint,5,opt,name=nowY,proto3" json:"nowY,omitempty"`
	Grids                []*MapUnit `protobuf:"bytes,6,rep,name=grids,proto3" json:"grids,omitempty"`
	ExtraStrength        int32      `protobuf:"varint,7,opt,name=extra_strength,json=extraStrength,proto3" json:"extra_strength,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ReviveAck) Reset()         { *m = ReviveAck{} }
func (m *ReviveAck) String() string { return proto.CompactTextString(m) }
func (*ReviveAck) ProtoMessage()    {}
func (*ReviveAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{25}
}
func (m *ReviveAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReviveAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReviveAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReviveAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReviveAck.Merge(m, src)
}
func (m *ReviveAck) XXX_Size() int {
	return m.Size()
}
func (m *ReviveAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ReviveAck.DiscardUnknown(m)
}

var xxx_messageInfo_ReviveAck proto.InternalMessageInfo

func (m *ReviveAck) GetDead() bool {
	if m != nil {
		return m.Dead
	}
	return false
}

func (m *ReviveAck) GetStrength() int32 {
	if m != nil {
		return m.Strength
	}
	return 0
}

func (m *ReviveAck) GetGrid() *MapUnit {
	if m != nil {
		return m.Grid
	}
	return nil
}

func (m *ReviveAck) GetNowX() int32 {
	if m != nil {
		return m.NowX
	}
	return 0
}

func (m *ReviveAck) GetNowY() int32 {
	if m != nil {
		return m.NowY
	}
	return 0
}

func (m *ReviveAck) GetGrids() []*MapUnit {
	if m != nil {
		return m.Grids
	}
	return nil
}

func (m *ReviveAck) GetExtraStrength() int32 {
	if m != nil {
		return m.ExtraStrength
	}
	return 0
}

type ResetMapReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetMapReq) Reset()         { *m = ResetMapReq{} }
func (m *ResetMapReq) String() string { return proto.CompactTextString(m) }
func (*ResetMapReq) ProtoMessage()    {}
func (*ResetMapReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{26}
}
func (m *ResetMapReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetMapReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetMapReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetMapReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetMapReq.Merge(m, src)
}
func (m *ResetMapReq) XXX_Size() int {
	return m.Size()
}
func (m *ResetMapReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetMapReq.DiscardUnknown(m)
}

var xxx_messageInfo_ResetMapReq proto.InternalMessageInfo

type ResetMapAck struct {
	Strength             int32    `protobuf:"varint,1,opt,name=strength,proto3" json:"strength,omitempty"`
	Maps                 *Maps    `protobuf:"bytes,2,opt,name=maps,proto3" json:"maps,omitempty"`
	FreeResetMap         bool     `protobuf:"varint,3,opt,name=freeResetMap,proto3" json:"freeResetMap,omitempty"`
	ExtraStrength        int32    `protobuf:"varint,4,opt,name=extra_strength,json=extraStrength,proto3" json:"extra_strength,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetMapAck) Reset()         { *m = ResetMapAck{} }
func (m *ResetMapAck) String() string { return proto.CompactTextString(m) }
func (*ResetMapAck) ProtoMessage()    {}
func (*ResetMapAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{27}
}
func (m *ResetMapAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetMapAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetMapAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetMapAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetMapAck.Merge(m, src)
}
func (m *ResetMapAck) XXX_Size() int {
	return m.Size()
}
func (m *ResetMapAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetMapAck.DiscardUnknown(m)
}

var xxx_messageInfo_ResetMapAck proto.InternalMessageInfo

func (m *ResetMapAck) GetStrength() int32 {
	if m != nil {
		return m.Strength
	}
	return 0
}

func (m *ResetMapAck) GetMaps() *Maps {
	if m != nil {
		return m.Maps
	}
	return nil
}

func (m *ResetMapAck) GetFreeResetMap() bool {
	if m != nil {
		return m.FreeResetMap
	}
	return false
}

func (m *ResetMapAck) GetExtraStrength() int32 {
	if m != nil {
		return m.ExtraStrength
	}
	return 0
}

type UpLvReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpLvReq) Reset()         { *m = UpLvReq{} }
func (m *UpLvReq) String() string { return proto.CompactTextString(m) }
func (*UpLvReq) ProtoMessage()    {}
func (*UpLvReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{28}
}
func (m *UpLvReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpLvReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpLvReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpLvReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpLvReq.Merge(m, src)
}
func (m *UpLvReq) XXX_Size() int {
	return m.Size()
}
func (m *UpLvReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpLvReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpLvReq proto.InternalMessageInfo

type UpLvAck struct {
	Lv                   int32    `protobuf:"varint,1,opt,name=lv,proto3" json:"lv,omitempty"`
	Gold                 float64  `protobuf:"fixed64,2,opt,name=gold,proto3" json:"gold,omitempty"`
	FreeResetMap         bool     `protobuf:"varint,3,opt,name=freeResetMap,proto3" json:"freeResetMap,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpLvAck) Reset()         { *m = UpLvAck{} }
func (m *UpLvAck) String() string { return proto.CompactTextString(m) }
func (*UpLvAck) ProtoMessage()    {}
func (*UpLvAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{29}
}
func (m *UpLvAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpLvAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpLvAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpLvAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpLvAck.Merge(m, src)
}
func (m *UpLvAck) XXX_Size() int {
	return m.Size()
}
func (m *UpLvAck) XXX_DiscardUnknown() {
	xxx_messageInfo_UpLvAck.DiscardUnknown(m)
}

var xxx_messageInfo_UpLvAck proto.InternalMessageInfo

func (m *UpLvAck) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *UpLvAck) GetGold() float64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *UpLvAck) GetFreeResetMap() bool {
	if m != nil {
		return m.FreeResetMap
	}
	return false
}

type StrengthNtf struct {
	Strength             int32    `protobuf:"varint,1,opt,name=strength,proto3" json:"strength,omitempty"`
	ExtraStrength        int32    `protobuf:"varint,2,opt,name=extra_strength,json=extraStrength,proto3" json:"extra_strength,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StrengthNtf) Reset()         { *m = StrengthNtf{} }
func (m *StrengthNtf) String() string { return proto.CompactTextString(m) }
func (*StrengthNtf) ProtoMessage()    {}
func (*StrengthNtf) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{30}
}
func (m *StrengthNtf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StrengthNtf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StrengthNtf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StrengthNtf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StrengthNtf.Merge(m, src)
}
func (m *StrengthNtf) XXX_Size() int {
	return m.Size()
}
func (m *StrengthNtf) XXX_DiscardUnknown() {
	xxx_messageInfo_StrengthNtf.DiscardUnknown(m)
}

var xxx_messageInfo_StrengthNtf proto.InternalMessageInfo

func (m *StrengthNtf) GetStrength() int32 {
	if m != nil {
		return m.Strength
	}
	return 0
}

func (m *StrengthNtf) GetExtraStrength() int32 {
	if m != nil {
		return m.ExtraStrength
	}
	return 0
}

type IncomeNtf struct {
	Gold                 float64    `protobuf:"fixed64,1,opt,name=gold,proto3" json:"gold,omitempty"`
	IncomeType           IncomeType `protobuf:"varint,2,opt,name=incomeType,proto3,enum=IncomeType" json:"incomeType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *IncomeNtf) Reset()         { *m = IncomeNtf{} }
func (m *IncomeNtf) String() string { return proto.CompactTextString(m) }
func (*IncomeNtf) ProtoMessage()    {}
func (*IncomeNtf) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{31}
}
func (m *IncomeNtf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncomeNtf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncomeNtf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncomeNtf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncomeNtf.Merge(m, src)
}
func (m *IncomeNtf) XXX_Size() int {
	return m.Size()
}
func (m *IncomeNtf) XXX_DiscardUnknown() {
	xxx_messageInfo_IncomeNtf.DiscardUnknown(m)
}

var xxx_messageInfo_IncomeNtf proto.InternalMessageInfo

func (m *IncomeNtf) GetGold() float64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *IncomeNtf) GetIncomeType() IncomeType {
	if m != nil {
		return m.IncomeType
	}
	return IncomeType_Off
}

type DiamondNtf struct {
	Diamond              int32       `protobuf:"varint,1,opt,name=diamond,proto3" json:"diamond,omitempty"`
	DiamondType          DiamondType `protobuf:"varint,2,opt,name=diamondType,proto3,enum=DiamondType" json:"diamondType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DiamondNtf) Reset()         { *m = DiamondNtf{} }
func (m *DiamondNtf) String() string { return proto.CompactTextString(m) }
func (*DiamondNtf) ProtoMessage()    {}
func (*DiamondNtf) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{32}
}
func (m *DiamondNtf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiamondNtf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiamondNtf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiamondNtf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiamondNtf.Merge(m, src)
}
func (m *DiamondNtf) XXX_Size() int {
	return m.Size()
}
func (m *DiamondNtf) XXX_DiscardUnknown() {
	xxx_messageInfo_DiamondNtf.DiscardUnknown(m)
}

var xxx_messageInfo_DiamondNtf proto.InternalMessageInfo

func (m *DiamondNtf) GetDiamond() int32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *DiamondNtf) GetDiamondType() DiamondType {
	if m != nil {
		return m.DiamondType
	}
	return DiamondType_Invite
}

type CardReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CardReq) Reset()         { *m = CardReq{} }
func (m *CardReq) String() string { return proto.CompactTextString(m) }
func (*CardReq) ProtoMessage()    {}
func (*CardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{33}
}
func (m *CardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardReq.Merge(m, src)
}
func (m *CardReq) XXX_Size() int {
	return m.Size()
}
func (m *CardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CardReq.DiscardUnknown(m)
}

var xxx_messageInfo_CardReq proto.InternalMessageInfo

type CardAck struct {
	Data                 map[int32]int32 `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CardAck) Reset()         { *m = CardAck{} }
func (m *CardAck) String() string { return proto.CompactTextString(m) }
func (*CardAck) ProtoMessage()    {}
func (*CardAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{34}
}
func (m *CardAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardAck.Merge(m, src)
}
func (m *CardAck) XXX_Size() int {
	return m.Size()
}
func (m *CardAck) XXX_DiscardUnknown() {
	xxx_messageInfo_CardAck.DiscardUnknown(m)
}

var xxx_messageInfo_CardAck proto.InternalMessageInfo

func (m *CardAck) GetData() map[int32]int32 {
	if m != nil {
		return m.Data
	}
	return nil
}

type CardNtf struct {
	Data                 map[int32]int32 `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CardNtf) Reset()         { *m = CardNtf{} }
func (m *CardNtf) String() string { return proto.CompactTextString(m) }
func (*CardNtf) ProtoMessage()    {}
func (*CardNtf) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{35}
}
func (m *CardNtf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardNtf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardNtf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardNtf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardNtf.Merge(m, src)
}
func (m *CardNtf) XXX_Size() int {
	return m.Size()
}
func (m *CardNtf) XXX_DiscardUnknown() {
	xxx_messageInfo_CardNtf.DiscardUnknown(m)
}

var xxx_messageInfo_CardNtf proto.InternalMessageInfo

func (m *CardNtf) GetData() map[int32]int32 {
	if m != nil {
		return m.Data
	}
	return nil
}

type CardUpLvReq struct {
	Id                   int32       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ConsumeType          ConsumeType `protobuf:"varint,2,opt,name=consumeType,proto3,enum=ConsumeType" json:"consumeType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CardUpLvReq) Reset()         { *m = CardUpLvReq{} }
func (m *CardUpLvReq) String() string { return proto.CompactTextString(m) }
func (*CardUpLvReq) ProtoMessage()    {}
func (*CardUpLvReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{36}
}
func (m *CardUpLvReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardUpLvReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardUpLvReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardUpLvReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardUpLvReq.Merge(m, src)
}
func (m *CardUpLvReq) XXX_Size() int {
	return m.Size()
}
func (m *CardUpLvReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CardUpLvReq.DiscardUnknown(m)
}

var xxx_messageInfo_CardUpLvReq proto.InternalMessageInfo

func (m *CardUpLvReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CardUpLvReq) GetConsumeType() ConsumeType {
	if m != nil {
		return m.ConsumeType
	}
	return ConsumeType_Gold
}

type CardUpLvAck struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Lv                   int32    `protobuf:"varint,2,opt,name=lv,proto3" json:"lv,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CardUpLvAck) Reset()         { *m = CardUpLvAck{} }
func (m *CardUpLvAck) String() string { return proto.CompactTextString(m) }
func (*CardUpLvAck) ProtoMessage()    {}
func (*CardUpLvAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{37}
}
func (m *CardUpLvAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardUpLvAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardUpLvAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CardUpLvAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardUpLvAck.Merge(m, src)
}
func (m *CardUpLvAck) XXX_Size() int {
	return m.Size()
}
func (m *CardUpLvAck) XXX_DiscardUnknown() {
	xxx_messageInfo_CardUpLvAck.DiscardUnknown(m)
}

var xxx_messageInfo_CardUpLvAck proto.InternalMessageInfo

func (m *CardUpLvAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CardUpLvAck) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

type ShopUnit struct {
	ShopBuyType          ShopType `protobuf:"varint,1,opt,name=shopBuyType,proto3,enum=ShopType" json:"shopBuyType,omitempty"`
	BuyNum               int32    `protobuf:"varint,2,opt,name=buyNum,proto3" json:"buyNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShopUnit) Reset()         { *m = ShopUnit{} }
func (m *ShopUnit) String() string { return proto.CompactTextString(m) }
func (*ShopUnit) ProtoMessage()    {}
func (*ShopUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{38}
}
func (m *ShopUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShopUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShopUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShopUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShopUnit.Merge(m, src)
}
func (m *ShopUnit) XXX_Size() int {
	return m.Size()
}
func (m *ShopUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_ShopUnit.DiscardUnknown(m)
}

var xxx_messageInfo_ShopUnit proto.InternalMessageInfo

func (m *ShopUnit) GetShopBuyType() ShopType {
	if m != nil {
		return m.ShopBuyType
	}
	return ShopType_Default
}

func (m *ShopUnit) GetBuyNum() int32 {
	if m != nil {
		return m.BuyNum
	}
	return 0
}

type ShopBuyReq struct {
	ShopId               int32    `protobuf:"varint,1,opt,name=shopId,proto3" json:"shopId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShopBuyReq) Reset()         { *m = ShopBuyReq{} }
func (m *ShopBuyReq) String() string { return proto.CompactTextString(m) }
func (*ShopBuyReq) ProtoMessage()    {}
func (*ShopBuyReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{39}
}
func (m *ShopBuyReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShopBuyReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShopBuyReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShopBuyReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShopBuyReq.Merge(m, src)
}
func (m *ShopBuyReq) XXX_Size() int {
	return m.Size()
}
func (m *ShopBuyReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ShopBuyReq.DiscardUnknown(m)
}

var xxx_messageInfo_ShopBuyReq proto.InternalMessageInfo

func (m *ShopBuyReq) GetShopId() int32 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

type ShopBuyAck struct {
	ShopId               int32     `protobuf:"varint,1,opt,name=shopId,proto3" json:"shopId,omitempty"`
	Diamond              int32     `protobuf:"varint,2,opt,name=diamond,proto3" json:"diamond,omitempty"`
	Strength             int32     `protobuf:"varint,3,opt,name=strength,proto3" json:"strength,omitempty"`
	Info                 *ShopUnit `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
	ExtraStrength        int32     `protobuf:"varint,5,opt,name=extra_strength,json=extraStrength,proto3" json:"extra_strength,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ShopBuyAck) Reset()         { *m = ShopBuyAck{} }
func (m *ShopBuyAck) String() string { return proto.CompactTextString(m) }
func (*ShopBuyAck) ProtoMessage()    {}
func (*ShopBuyAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{40}
}
func (m *ShopBuyAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShopBuyAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShopBuyAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShopBuyAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShopBuyAck.Merge(m, src)
}
func (m *ShopBuyAck) XXX_Size() int {
	return m.Size()
}
func (m *ShopBuyAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ShopBuyAck.DiscardUnknown(m)
}

var xxx_messageInfo_ShopBuyAck proto.InternalMessageInfo

func (m *ShopBuyAck) GetShopId() int32 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *ShopBuyAck) GetDiamond() int32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *ShopBuyAck) GetStrength() int32 {
	if m != nil {
		return m.Strength
	}
	return 0
}

func (m *ShopBuyAck) GetInfo() *ShopUnit {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *ShopBuyAck) GetExtraStrength() int32 {
	if m != nil {
		return m.ExtraStrength
	}
	return 0
}

type HastenUnit struct {
	HastenType           HastenType `protobuf:"varint,1,opt,name=hastenType,proto3,enum=HastenType" json:"hastenType,omitempty"`
	StartTime            int64      `protobuf:"varint,2,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime              int64      `protobuf:"varint,3,opt,name=endTime,proto3" json:"endTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *HastenUnit) Reset()         { *m = HastenUnit{} }
func (m *HastenUnit) String() string { return proto.CompactTextString(m) }
func (*HastenUnit) ProtoMessage()    {}
func (*HastenUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{41}
}
func (m *HastenUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HastenUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HastenUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HastenUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HastenUnit.Merge(m, src)
}
func (m *HastenUnit) XXX_Size() int {
	return m.Size()
}
func (m *HastenUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_HastenUnit.DiscardUnknown(m)
}

var xxx_messageInfo_HastenUnit proto.InternalMessageInfo

func (m *HastenUnit) GetHastenType() HastenType {
	if m != nil {
		return m.HastenType
	}
	return HastenType_Free
}

func (m *HastenUnit) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *HastenUnit) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type Hasten struct {
	Hasten               []*HastenUnit `protobuf:"bytes,1,rep,name=hasten,proto3" json:"hasten,omitempty"`
	EndTime              int64         `protobuf:"varint,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Hasten) Reset()         { *m = Hasten{} }
func (m *Hasten) String() string { return proto.CompactTextString(m) }
func (*Hasten) ProtoMessage()    {}
func (*Hasten) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{42}
}
func (m *Hasten) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Hasten) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Hasten.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Hasten) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Hasten.Merge(m, src)
}
func (m *Hasten) XXX_Size() int {
	return m.Size()
}
func (m *Hasten) XXX_DiscardUnknown() {
	xxx_messageInfo_Hasten.DiscardUnknown(m)
}

var xxx_messageInfo_Hasten proto.InternalMessageInfo

func (m *Hasten) GetHasten() []*HastenUnit {
	if m != nil {
		return m.Hasten
	}
	return nil
}

func (m *Hasten) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type HastenReq struct {
	HastenType           HastenType `protobuf:"varint,1,opt,name=hastenType,proto3,enum=HastenType" json:"hastenType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *HastenReq) Reset()         { *m = HastenReq{} }
func (m *HastenReq) String() string { return proto.CompactTextString(m) }
func (*HastenReq) ProtoMessage()    {}
func (*HastenReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{43}
}
func (m *HastenReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HastenReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HastenReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HastenReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HastenReq.Merge(m, src)
}
func (m *HastenReq) XXX_Size() int {
	return m.Size()
}
func (m *HastenReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HastenReq.DiscardUnknown(m)
}

var xxx_messageInfo_HastenReq proto.InternalMessageInfo

func (m *HastenReq) GetHastenType() HastenType {
	if m != nil {
		return m.HastenType
	}
	return HastenType_Free
}

type HastenAck struct {
	Hasten               *HastenUnit `protobuf:"bytes,1,opt,name=hasten,proto3" json:"hasten,omitempty"`
	EndTime              int64       `protobuf:"varint,2,opt,name=endTime,proto3" json:"endTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *HastenAck) Reset()         { *m = HastenAck{} }
func (m *HastenAck) String() string { return proto.CompactTextString(m) }
func (*HastenAck) ProtoMessage()    {}
func (*HastenAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{44}
}
func (m *HastenAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HastenAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HastenAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HastenAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HastenAck.Merge(m, src)
}
func (m *HastenAck) XXX_Size() int {
	return m.Size()
}
func (m *HastenAck) XXX_DiscardUnknown() {
	xxx_messageInfo_HastenAck.DiscardUnknown(m)
}

var xxx_messageInfo_HastenAck proto.InternalMessageInfo

func (m *HastenAck) GetHasten() *HastenUnit {
	if m != nil {
		return m.Hasten
	}
	return nil
}

func (m *HastenAck) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

type InviteUnit struct {
	Uid                  uint64   `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Head                 string   `protobuf:"bytes,2,opt,name=head,proto3" json:"head,omitempty"`
	FirstName            string   `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName             string   `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	UserName             string   `protobuf:"bytes,5,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	Lv                   int32    `protobuf:"varint,6,opt,name=lv,proto3" json:"lv,omitempty"`
	Diamond              int32    `protobuf:"varint,7,opt,name=diamond,proto3" json:"diamond,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InviteUnit) Reset()         { *m = InviteUnit{} }
func (m *InviteUnit) String() string { return proto.CompactTextString(m) }
func (*InviteUnit) ProtoMessage()    {}
func (*InviteUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{45}
}
func (m *InviteUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InviteUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InviteUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InviteUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InviteUnit.Merge(m, src)
}
func (m *InviteUnit) XXX_Size() int {
	return m.Size()
}
func (m *InviteUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_InviteUnit.DiscardUnknown(m)
}

var xxx_messageInfo_InviteUnit proto.InternalMessageInfo

func (m *InviteUnit) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *InviteUnit) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *InviteUnit) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *InviteUnit) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *InviteUnit) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *InviteUnit) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *InviteUnit) GetDiamond() int32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

type InviteReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InviteReq) Reset()         { *m = InviteReq{} }
func (m *InviteReq) String() string { return proto.CompactTextString(m) }
func (*InviteReq) ProtoMessage()    {}
func (*InviteReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{46}
}
func (m *InviteReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InviteReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InviteReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InviteReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InviteReq.Merge(m, src)
}
func (m *InviteReq) XXX_Size() int {
	return m.Size()
}
func (m *InviteReq) XXX_DiscardUnknown() {
	xxx_messageInfo_InviteReq.DiscardUnknown(m)
}

var xxx_messageInfo_InviteReq proto.InternalMessageInfo

type InviteAck struct {
	Rewards              []int32       `protobuf:"varint,1,rep,packed,name=rewards,proto3" json:"rewards,omitempty"`
	Invites              []*InviteUnit `protobuf:"bytes,2,rep,name=invites,proto3" json:"invites,omitempty"`
	Flag                 bool          `protobuf:"varint,3,opt,name=flag,proto3" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *InviteAck) Reset()         { *m = InviteAck{} }
func (m *InviteAck) String() string { return proto.CompactTextString(m) }
func (*InviteAck) ProtoMessage()    {}
func (*InviteAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{47}
}
func (m *InviteAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InviteAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InviteAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InviteAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InviteAck.Merge(m, src)
}
func (m *InviteAck) XXX_Size() int {
	return m.Size()
}
func (m *InviteAck) XXX_DiscardUnknown() {
	xxx_messageInfo_InviteAck.DiscardUnknown(m)
}

var xxx_messageInfo_InviteAck proto.InternalMessageInfo

func (m *InviteAck) GetRewards() []int32 {
	if m != nil {
		return m.Rewards
	}
	return nil
}

func (m *InviteAck) GetInvites() []*InviteUnit {
	if m != nil {
		return m.Invites
	}
	return nil
}

func (m *InviteAck) GetFlag() bool {
	if m != nil {
		return m.Flag
	}
	return false
}

type InviteRewardReq struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InviteRewardReq) Reset()         { *m = InviteRewardReq{} }
func (m *InviteRewardReq) String() string { return proto.CompactTextString(m) }
func (*InviteRewardReq) ProtoMessage()    {}
func (*InviteRewardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{48}
}
func (m *InviteRewardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InviteRewardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InviteRewardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InviteRewardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InviteRewardReq.Merge(m, src)
}
func (m *InviteRewardReq) XXX_Size() int {
	return m.Size()
}
func (m *InviteRewardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_InviteRewardReq.DiscardUnknown(m)
}

var xxx_messageInfo_InviteRewardReq proto.InternalMessageInfo

func (m *InviteRewardReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type InviteRewardAck struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InviteRewardAck) Reset()         { *m = InviteRewardAck{} }
func (m *InviteRewardAck) String() string { return proto.CompactTextString(m) }
func (*InviteRewardAck) ProtoMessage()    {}
func (*InviteRewardAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{49}
}
func (m *InviteRewardAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InviteRewardAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InviteRewardAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InviteRewardAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InviteRewardAck.Merge(m, src)
}
func (m *InviteRewardAck) XXX_Size() int {
	return m.Size()
}
func (m *InviteRewardAck) XXX_DiscardUnknown() {
	xxx_messageInfo_InviteRewardAck.DiscardUnknown(m)
}

var xxx_messageInfo_InviteRewardAck proto.InternalMessageInfo

func (m *InviteRewardAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type InviteNtf struct {
	Invitees             uint64   `protobuf:"varint,1,opt,name=invitees,proto3" json:"invitees,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InviteNtf) Reset()         { *m = InviteNtf{} }
func (m *InviteNtf) String() string { return proto.CompactTextString(m) }
func (*InviteNtf) ProtoMessage()    {}
func (*InviteNtf) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{50}
}
func (m *InviteNtf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InviteNtf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InviteNtf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InviteNtf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InviteNtf.Merge(m, src)
}
func (m *InviteNtf) XXX_Size() int {
	return m.Size()
}
func (m *InviteNtf) XXX_DiscardUnknown() {
	xxx_messageInfo_InviteNtf.DiscardUnknown(m)
}

var xxx_messageInfo_InviteNtf proto.InternalMessageInfo

func (m *InviteNtf) GetInvitees() uint64 {
	if m != nil {
		return m.Invitees
	}
	return 0
}

type RedPointUnit struct {
	RedPointType         RedPointType `protobuf:"varint,1,opt,name=redPointType,proto3,enum=RedPointType" json:"redPointType,omitempty"`
	Flag                 bool         `protobuf:"varint,2,opt,name=flag,proto3" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RedPointUnit) Reset()         { *m = RedPointUnit{} }
func (m *RedPointUnit) String() string { return proto.CompactTextString(m) }
func (*RedPointUnit) ProtoMessage()    {}
func (*RedPointUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{51}
}
func (m *RedPointUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedPointUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedPointUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedPointUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedPointUnit.Merge(m, src)
}
func (m *RedPointUnit) XXX_Size() int {
	return m.Size()
}
func (m *RedPointUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_RedPointUnit.DiscardUnknown(m)
}

var xxx_messageInfo_RedPointUnit proto.InternalMessageInfo

func (m *RedPointUnit) GetRedPointType() RedPointType {
	if m != nil {
		return m.RedPointType
	}
	return RedPointType_RedPointType_Empty
}

func (m *RedPointUnit) GetFlag() bool {
	if m != nil {
		return m.Flag
	}
	return false
}

type RedPointReq struct {
	RedPointType         RedPointType `protobuf:"varint,1,opt,name=redPointType,proto3,enum=RedPointType" json:"redPointType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RedPointReq) Reset()         { *m = RedPointReq{} }
func (m *RedPointReq) String() string { return proto.CompactTextString(m) }
func (*RedPointReq) ProtoMessage()    {}
func (*RedPointReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{52}
}
func (m *RedPointReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedPointReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedPointReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedPointReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedPointReq.Merge(m, src)
}
func (m *RedPointReq) XXX_Size() int {
	return m.Size()
}
func (m *RedPointReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RedPointReq.DiscardUnknown(m)
}

var xxx_messageInfo_RedPointReq proto.InternalMessageInfo

func (m *RedPointReq) GetRedPointType() RedPointType {
	if m != nil {
		return m.RedPointType
	}
	return RedPointType_RedPointType_Empty
}

type RedPointAck struct {
	RedPoint             *RedPointUnit `protobuf:"bytes,1,opt,name=redPoint,proto3" json:"redPoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RedPointAck) Reset()         { *m = RedPointAck{} }
func (m *RedPointAck) String() string { return proto.CompactTextString(m) }
func (*RedPointAck) ProtoMessage()    {}
func (*RedPointAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{53}
}
func (m *RedPointAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedPointAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedPointAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedPointAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedPointAck.Merge(m, src)
}
func (m *RedPointAck) XXX_Size() int {
	return m.Size()
}
func (m *RedPointAck) XXX_DiscardUnknown() {
	xxx_messageInfo_RedPointAck.DiscardUnknown(m)
}

var xxx_messageInfo_RedPointAck proto.InternalMessageInfo

func (m *RedPointAck) GetRedPoint() *RedPointUnit {
	if m != nil {
		return m.RedPoint
	}
	return nil
}

type RedPointNtf struct {
	RedPoint             []*RedPointUnit `protobuf:"bytes,1,rep,name=redPoint,proto3" json:"redPoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RedPointNtf) Reset()         { *m = RedPointNtf{} }
func (m *RedPointNtf) String() string { return proto.CompactTextString(m) }
func (*RedPointNtf) ProtoMessage()    {}
func (*RedPointNtf) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{54}
}
func (m *RedPointNtf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedPointNtf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedPointNtf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedPointNtf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedPointNtf.Merge(m, src)
}
func (m *RedPointNtf) XXX_Size() int {
	return m.Size()
}
func (m *RedPointNtf) XXX_DiscardUnknown() {
	xxx_messageInfo_RedPointNtf.DiscardUnknown(m)
}

var xxx_messageInfo_RedPointNtf proto.InternalMessageInfo

func (m *RedPointNtf) GetRedPoint() []*RedPointUnit {
	if m != nil {
		return m.RedPoint
	}
	return nil
}

type RankUnit struct {
	Uid                  uint64   `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Ranking              int32    `protobuf:"varint,2,opt,name=ranking,proto3" json:"ranking,omitempty"`
	Head                 string   `protobuf:"bytes,3,opt,name=head,proto3" json:"head,omitempty"`
	FirstName            string   `protobuf:"bytes,4,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName             string   `protobuf:"bytes,5,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	UserName             string   `protobuf:"bytes,6,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	Gold                 float64  `protobuf:"fixed64,7,opt,name=gold,proto3" json:"gold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RankUnit) Reset()         { *m = RankUnit{} }
func (m *RankUnit) String() string { return proto.CompactTextString(m) }
func (*RankUnit) ProtoMessage()    {}
func (*RankUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{55}
}
func (m *RankUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankUnit.Merge(m, src)
}
func (m *RankUnit) XXX_Size() int {
	return m.Size()
}
func (m *RankUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_RankUnit.DiscardUnknown(m)
}

var xxx_messageInfo_RankUnit proto.InternalMessageInfo

func (m *RankUnit) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RankUnit) GetRanking() int32 {
	if m != nil {
		return m.Ranking
	}
	return 0
}

func (m *RankUnit) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *RankUnit) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *RankUnit) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *RankUnit) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *RankUnit) GetGold() float64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

type RankReq struct {
	RankType             RankType `protobuf:"varint,1,opt,name=rankType,proto3,enum=RankType" json:"rankType,omitempty"`
	Lv                   int32    `protobuf:"varint,2,opt,name=lv,proto3" json:"lv,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RankReq) Reset()         { *m = RankReq{} }
func (m *RankReq) String() string { return proto.CompactTextString(m) }
func (*RankReq) ProtoMessage()    {}
func (*RankReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{56}
}
func (m *RankReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankReq.Merge(m, src)
}
func (m *RankReq) XXX_Size() int {
	return m.Size()
}
func (m *RankReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RankReq.DiscardUnknown(m)
}

var xxx_messageInfo_RankReq proto.InternalMessageInfo

func (m *RankReq) GetRankType() RankType {
	if m != nil {
		return m.RankType
	}
	return RankType_RankType_Empty
}

func (m *RankReq) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

type RankAck struct {
	RankType             RankType    `protobuf:"varint,1,opt,name=rankType,proto3,enum=RankType" json:"rankType,omitempty"`
	Lv                   int32       `protobuf:"varint,2,opt,name=lv,proto3" json:"lv,omitempty"`
	List                 []*RankUnit `protobuf:"bytes,3,rep,name=list,proto3" json:"list,omitempty"`
	Me                   *RankUnit   `protobuf:"bytes,4,opt,name=me,proto3" json:"me,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RankAck) Reset()         { *m = RankAck{} }
func (m *RankAck) String() string { return proto.CompactTextString(m) }
func (*RankAck) ProtoMessage()    {}
func (*RankAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{57}
}
func (m *RankAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RankAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RankAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RankAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RankAck.Merge(m, src)
}
func (m *RankAck) XXX_Size() int {
	return m.Size()
}
func (m *RankAck) XXX_DiscardUnknown() {
	xxx_messageInfo_RankAck.DiscardUnknown(m)
}

var xxx_messageInfo_RankAck proto.InternalMessageInfo

func (m *RankAck) GetRankType() RankType {
	if m != nil {
		return m.RankType
	}
	return RankType_RankType_Empty
}

func (m *RankAck) GetLv() int32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

func (m *RankAck) GetList() []*RankUnit {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *RankAck) GetMe() *RankUnit {
	if m != nil {
		return m.Me
	}
	return nil
}

type GuildUnit struct {
	GuildId              uint64   `protobuf:"varint,1,opt,name=guildId,proto3" json:"guildId,omitempty"`
	Ranking              int32    `protobuf:"varint,2,opt,name=ranking,proto3" json:"ranking,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Member               int32    `protobuf:"varint,4,opt,name=member,proto3" json:"member,omitempty"`
	Gold                 float64  `protobuf:"fixed64,5,opt,name=gold,proto3" json:"gold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuildUnit) Reset()         { *m = GuildUnit{} }
func (m *GuildUnit) String() string { return proto.CompactTextString(m) }
func (*GuildUnit) ProtoMessage()    {}
func (*GuildUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{58}
}
func (m *GuildUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildUnit.Merge(m, src)
}
func (m *GuildUnit) XXX_Size() int {
	return m.Size()
}
func (m *GuildUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildUnit.DiscardUnknown(m)
}

var xxx_messageInfo_GuildUnit proto.InternalMessageInfo

func (m *GuildUnit) GetGuildId() uint64 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *GuildUnit) GetRanking() int32 {
	if m != nil {
		return m.Ranking
	}
	return 0
}

func (m *GuildUnit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GuildUnit) GetMember() int32 {
	if m != nil {
		return m.Member
	}
	return 0
}

func (m *GuildUnit) GetGold() float64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

type GuildListReq struct {
	RankType             RankType `protobuf:"varint,1,opt,name=rankType,proto3,enum=RankType" json:"rankType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuildListReq) Reset()         { *m = GuildListReq{} }
func (m *GuildListReq) String() string { return proto.CompactTextString(m) }
func (*GuildListReq) ProtoMessage()    {}
func (*GuildListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{59}
}
func (m *GuildListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildListReq.Merge(m, src)
}
func (m *GuildListReq) XXX_Size() int {
	return m.Size()
}
func (m *GuildListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildListReq.DiscardUnknown(m)
}

var xxx_messageInfo_GuildListReq proto.InternalMessageInfo

func (m *GuildListReq) GetRankType() RankType {
	if m != nil {
		return m.RankType
	}
	return RankType_RankType_Empty
}

type GuildListAck struct {
	RankType             RankType     `protobuf:"varint,1,opt,name=rankType,proto3,enum=RankType" json:"rankType,omitempty"`
	List                 []*GuildUnit `protobuf:"bytes,2,rep,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GuildListAck) Reset()         { *m = GuildListAck{} }
func (m *GuildListAck) String() string { return proto.CompactTextString(m) }
func (*GuildListAck) ProtoMessage()    {}
func (*GuildListAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{60}
}
func (m *GuildListAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildListAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildListAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildListAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildListAck.Merge(m, src)
}
func (m *GuildListAck) XXX_Size() int {
	return m.Size()
}
func (m *GuildListAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildListAck.DiscardUnknown(m)
}

var xxx_messageInfo_GuildListAck proto.InternalMessageInfo

func (m *GuildListAck) GetRankType() RankType {
	if m != nil {
		return m.RankType
	}
	return RankType_RankType_Empty
}

func (m *GuildListAck) GetList() []*GuildUnit {
	if m != nil {
		return m.List
	}
	return nil
}

type GuildRankReq struct {
	RankType             RankType `protobuf:"varint,1,opt,name=rankType,proto3,enum=RankType" json:"rankType,omitempty"`
	GuildId              uint64   `protobuf:"varint,2,opt,name=guildId,proto3" json:"guildId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuildRankReq) Reset()         { *m = GuildRankReq{} }
func (m *GuildRankReq) String() string { return proto.CompactTextString(m) }
func (*GuildRankReq) ProtoMessage()    {}
func (*GuildRankReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{61}
}
func (m *GuildRankReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildRankReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildRankReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildRankReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildRankReq.Merge(m, src)
}
func (m *GuildRankReq) XXX_Size() int {
	return m.Size()
}
func (m *GuildRankReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildRankReq.DiscardUnknown(m)
}

var xxx_messageInfo_GuildRankReq proto.InternalMessageInfo

func (m *GuildRankReq) GetRankType() RankType {
	if m != nil {
		return m.RankType
	}
	return RankType_RankType_Empty
}

func (m *GuildRankReq) GetGuildId() uint64 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

type GuildRankAck struct {
	RankType             RankType    `protobuf:"varint,1,opt,name=rankType,proto3,enum=RankType" json:"rankType,omitempty"`
	GuildId              uint64      `protobuf:"varint,2,opt,name=guildId,proto3" json:"guildId,omitempty"`
	List                 []*RankUnit `protobuf:"bytes,3,rep,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GuildRankAck) Reset()         { *m = GuildRankAck{} }
func (m *GuildRankAck) String() string { return proto.CompactTextString(m) }
func (*GuildRankAck) ProtoMessage()    {}
func (*GuildRankAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{62}
}
func (m *GuildRankAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildRankAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildRankAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildRankAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildRankAck.Merge(m, src)
}
func (m *GuildRankAck) XXX_Size() int {
	return m.Size()
}
func (m *GuildRankAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildRankAck.DiscardUnknown(m)
}

var xxx_messageInfo_GuildRankAck proto.InternalMessageInfo

func (m *GuildRankAck) GetRankType() RankType {
	if m != nil {
		return m.RankType
	}
	return RankType_RankType_Empty
}

func (m *GuildRankAck) GetGuildId() uint64 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *GuildRankAck) GetList() []*RankUnit {
	if m != nil {
		return m.List
	}
	return nil
}

type GuildJoinReq struct {
	GuildId              uint64   `protobuf:"varint,1,opt,name=guildId,proto3" json:"guildId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuildJoinReq) Reset()         { *m = GuildJoinReq{} }
func (m *GuildJoinReq) String() string { return proto.CompactTextString(m) }
func (*GuildJoinReq) ProtoMessage()    {}
func (*GuildJoinReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{63}
}
func (m *GuildJoinReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildJoinReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildJoinReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildJoinReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildJoinReq.Merge(m, src)
}
func (m *GuildJoinReq) XXX_Size() int {
	return m.Size()
}
func (m *GuildJoinReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildJoinReq.DiscardUnknown(m)
}

var xxx_messageInfo_GuildJoinReq proto.InternalMessageInfo

func (m *GuildJoinReq) GetGuildId() uint64 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

type GuildJoinAck struct {
	GuildId              uint64   `protobuf:"varint,1,opt,name=guildId,proto3" json:"guildId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuildJoinAck) Reset()         { *m = GuildJoinAck{} }
func (m *GuildJoinAck) String() string { return proto.CompactTextString(m) }
func (*GuildJoinAck) ProtoMessage()    {}
func (*GuildJoinAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{64}
}
func (m *GuildJoinAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildJoinAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildJoinAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildJoinAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildJoinAck.Merge(m, src)
}
func (m *GuildJoinAck) XXX_Size() int {
	return m.Size()
}
func (m *GuildJoinAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildJoinAck.DiscardUnknown(m)
}

var xxx_messageInfo_GuildJoinAck proto.InternalMessageInfo

func (m *GuildJoinAck) GetGuildId() uint64 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

type GuildLeaveReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuildLeaveReq) Reset()         { *m = GuildLeaveReq{} }
func (m *GuildLeaveReq) String() string { return proto.CompactTextString(m) }
func (*GuildLeaveReq) ProtoMessage()    {}
func (*GuildLeaveReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{65}
}
func (m *GuildLeaveReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildLeaveReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildLeaveReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildLeaveReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildLeaveReq.Merge(m, src)
}
func (m *GuildLeaveReq) XXX_Size() int {
	return m.Size()
}
func (m *GuildLeaveReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildLeaveReq.DiscardUnknown(m)
}

var xxx_messageInfo_GuildLeaveReq proto.InternalMessageInfo

type GuildLeaveAck struct {
	Flag                 bool     `protobuf:"varint,1,opt,name=flag,proto3" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuildLeaveAck) Reset()         { *m = GuildLeaveAck{} }
func (m *GuildLeaveAck) String() string { return proto.CompactTextString(m) }
func (*GuildLeaveAck) ProtoMessage()    {}
func (*GuildLeaveAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_6157791a552b217f, []int{66}
}
func (m *GuildLeaveAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildLeaveAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildLeaveAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildLeaveAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildLeaveAck.Merge(m, src)
}
func (m *GuildLeaveAck) XXX_Size() int {
	return m.Size()
}
func (m *GuildLeaveAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildLeaveAck.DiscardUnknown(m)
}

var xxx_messageInfo_GuildLeaveAck proto.InternalMessageInfo

func (m *GuildLeaveAck) GetFlag() bool {
	if m != nil {
		return m.Flag
	}
	return false
}

func init() {
	proto.RegisterType((*Heartbeat)(nil), "Heartbeat")
	proto.RegisterType((*KickNtf)(nil), "KickNtf")
	proto.RegisterType((*ErrNtf)(nil), "ErrNtf")
	proto.RegisterType((*GmReq)(nil), "GmReq")
	proto.RegisterType((*GmAck)(nil), "GmAck")
	proto.RegisterType((*TestMsg)(nil), "TestMsg")
	proto.RegisterType((*LoginReq)(nil), "LoginReq")
	proto.RegisterType((*LoginAck)(nil), "LoginAck")
	proto.RegisterType((*VerifyReq)(nil), "VerifyReq")
	proto.RegisterType((*VerifyAck)(nil), "VerifyAck")
	proto.RegisterType((*ReconnectReq)(nil), "ReconnectReq")
	proto.RegisterType((*ReconnectAck)(nil), "ReconnectAck")
	proto.RegisterType((*MapUnit)(nil), "MapUnit")
	proto.RegisterType((*Maps)(nil), "Maps")
	proto.RegisterType((*EnterReq)(nil), "EnterReq")
	proto.RegisterType((*EnterNtf)(nil), "EnterNtf")
	proto.RegisterType((*MoveReq)(nil), "MoveReq")
	proto.RegisterType((*MoveAck)(nil), "MoveAck")
	proto.RegisterType((*OpenWallReq)(nil), "OpenWallReq")
	proto.RegisterType((*OpenWallAck)(nil), "OpenWallAck")
	proto.RegisterType((*GetTreasureReq)(nil), "GetTreasureReq")
	proto.RegisterType((*GetTreasureAck)(nil), "GetTreasureAck")
	proto.RegisterType((*OpenTreasureReq)(nil), "OpenTreasureReq")
	proto.RegisterType((*OpenTreasureAck)(nil), "OpenTreasureAck")
	proto.RegisterType((*ReviveReq)(nil), "ReviveReq")
	proto.RegisterType((*ReviveAck)(nil), "ReviveAck")
	proto.RegisterType((*ResetMapReq)(nil), "ResetMapReq")
	proto.RegisterType((*ResetMapAck)(nil), "ResetMapAck")
	proto.RegisterType((*UpLvReq)(nil), "UpLvReq")
	proto.RegisterType((*UpLvAck)(nil), "UpLvAck")
	proto.RegisterType((*StrengthNtf)(nil), "StrengthNtf")
	proto.RegisterType((*IncomeNtf)(nil), "IncomeNtf")
	proto.RegisterType((*DiamondNtf)(nil), "DiamondNtf")
	proto.RegisterType((*CardReq)(nil), "CardReq")
	proto.RegisterType((*CardAck)(nil), "CardAck")
	proto.RegisterMapType((map[int32]int32)(nil), "CardAck.DataEntry")
	proto.RegisterType((*CardNtf)(nil), "CardNtf")
	proto.RegisterMapType((map[int32]int32)(nil), "CardNtf.DataEntry")
	proto.RegisterType((*CardUpLvReq)(nil), "CardUpLvReq")
	proto.RegisterType((*CardUpLvAck)(nil), "CardUpLvAck")
	proto.RegisterType((*ShopUnit)(nil), "ShopUnit")
	proto.RegisterType((*ShopBuyReq)(nil), "ShopBuyReq")
	proto.RegisterType((*ShopBuyAck)(nil), "ShopBuyAck")
	proto.RegisterType((*HastenUnit)(nil), "HastenUnit")
	proto.RegisterType((*Hasten)(nil), "Hasten")
	proto.RegisterType((*HastenReq)(nil), "HastenReq")
	proto.RegisterType((*HastenAck)(nil), "HastenAck")
	proto.RegisterType((*InviteUnit)(nil), "InviteUnit")
	proto.RegisterType((*InviteReq)(nil), "InviteReq")
	proto.RegisterType((*InviteAck)(nil), "InviteAck")
	proto.RegisterType((*InviteRewardReq)(nil), "InviteRewardReq")
	proto.RegisterType((*InviteRewardAck)(nil), "InviteRewardAck")
	proto.RegisterType((*InviteNtf)(nil), "InviteNtf")
	proto.RegisterType((*RedPointUnit)(nil), "RedPointUnit")
	proto.RegisterType((*RedPointReq)(nil), "RedPointReq")
	proto.RegisterType((*RedPointAck)(nil), "RedPointAck")
	proto.RegisterType((*RedPointNtf)(nil), "RedPointNtf")
	proto.RegisterType((*RankUnit)(nil), "RankUnit")
	proto.RegisterType((*RankReq)(nil), "RankReq")
	proto.RegisterType((*RankAck)(nil), "RankAck")
	proto.RegisterType((*GuildUnit)(nil), "GuildUnit")
	proto.RegisterType((*GuildListReq)(nil), "GuildListReq")
	proto.RegisterType((*GuildListAck)(nil), "GuildListAck")
	proto.RegisterType((*GuildRankReq)(nil), "GuildRankReq")
	proto.RegisterType((*GuildRankAck)(nil), "GuildRankAck")
	proto.RegisterType((*GuildJoinReq)(nil), "GuildJoinReq")
	proto.RegisterType((*GuildJoinAck)(nil), "GuildJoinAck")
	proto.RegisterType((*GuildLeaveReq)(nil), "GuildLeaveReq")
	proto.RegisterType((*GuildLeaveAck)(nil), "GuildLeaveAck")
}

func init() { proto.RegisterFile("c_msg.proto", fileDescriptor_6157791a552b217f) }

var fileDescriptor_6157791a552b217f = []byte{
	// 1687 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x18, 0xcb, 0x72, 0xd3, 0x56,
	0xb4, 0x92, 0x1f, 0xb2, 0x8e, 0x9d, 0xc0, 0x68, 0x18, 0xc6, 0x50, 0x30, 0x41, 0x90, 0x36, 0x0c,
	0x45, 0x33, 0xa5, 0xd3, 0x42, 0x3b, 0x2c, 0x78, 0x84, 0x09, 0xa1, 0x79, 0xd0, 0x4b, 0xa0, 0xd0,
	0x45, 0x53, 0xc5, 0xba, 0x71, 0xd4, 0xd8, 0x92, 0x23, 0x5d, 0x1b, 0xdc, 0x4d, 0x3f, 0xa1, 0xdb,
	0x2e, 0xfb, 0x09, 0xdd, 0x74, 0x3a, 0xd3, 0x2f, 0x60, 0xd9, 0x4f, 0xe8, 0xd0, 0x8f, 0xe8, 0xb6,
	0x73, 0xee, 0x43, 0xba, 0x8a, 0xed, 0x24, 0x66, 0xd8, 0xe9, 0x9c, 0x7b, 0xde, 0xaf, 0x7b, 0xae,
	0xa0, 0xde, 0xde, 0xee, 0xa5, 0x1d, 0xaf, 0x9f, 0xc4, 0x2c, 0x3e, 0xdf, 0x68, 0x6f, 0xd3, 0x68,
	0xd0, 0x13, 0x90, 0x5b, 0x07, 0xfb, 0x11, 0xf5, 0x13, 0xb6, 0x43, 0x7d, 0xe6, 0xde, 0x02, 0xeb,
	0xeb, 0xb0, 0xbd, 0xbf, 0xc1, 0x76, 0x9d, 0x33, 0x50, 0xa1, 0x49, 0xb2, 0x11, 0x37, 0x8d, 0x05,
	0x63, 0xa9, 0x42, 0x04, 0xe0, 0x9c, 0x85, 0x2a, 0x4d, 0x92, 0xf5, 0xb4, 0xd3, 0x34, 0x17, 0x8c,
	0x25, 0x9b, 0x48, 0xc8, 0xfd, 0x02, 0xaa, 0x0f, 0x93, 0x64, 0x76, 0xbe, 0x3b, 0x50, 0x59, 0xe9,
	0x11, 0x7a, 0xe0, 0x5c, 0x82, 0x6a, 0xa7, 0xb7, 0x35, 0xea, 0x53, 0xce, 0x37, 0x7f, 0xd3, 0xf2,
	0x56, 0x38, 0x48, 0x24, 0xda, 0x71, 0xa0, 0x1c, 0xf8, 0xcc, 0x97, 0xfc, 0xfc, 0x5b, 0x70, 0xdf,
	0x6b, 0xef, 0xbf, 0x1b, 0xb7, 0x0d, 0xd6, 0x16, 0x4d, 0x19, 0x9a, 0xf1, 0x3d, 0xd4, 0xd6, 0xe2,
	0x4e, 0x18, 0xa1, 0x25, 0x2d, 0x28, 0xb3, 0x5c, 0x12, 0x78, 0xfc, 0x80, 0x0b, 0xe3, 0x78, 0xe7,
	0x3c, 0xd4, 0xc2, 0x28, 0x64, 0xcb, 0xb9, 0xb8, 0x0c, 0x46, 0x37, 0xc3, 0x68, 0x18, 0x32, 0xda,
	0x2c, 0x2d, 0x18, 0x4b, 0x65, 0x22, 0x21, 0x77, 0x4b, 0xca, 0x47, 0x5b, 0xcf, 0x42, 0x75, 0x90,
	0xd2, 0x64, 0x75, 0x99, 0x6b, 0x28, 0x13, 0x09, 0x61, 0xe0, 0x58, 0xbc, 0x4f, 0x23, 0x29, 0x54,
	0x00, 0xa8, 0xad, 0x1b, 0x46, 0xfb, 0xf7, 0x82, 0x20, 0xe1, 0x32, 0x6d, 0x92, 0xc1, 0xee, 0x65,
	0xb0, 0x9f, 0xd3, 0x24, 0xdc, 0x1d, 0xa1, 0xd9, 0x19, 0xbb, 0xa1, 0xb1, 0xbb, 0x5f, 0x2a, 0x12,
	0xd4, 0x3c, 0x5b, 0x6a, 0xae, 0x42, 0x83, 0xd0, 0x76, 0x1c, 0x45, 0xb4, 0xcd, 0xa6, 0x2b, 0xb8,
	0xa3, 0x51, 0xcd, 0xae, 0x63, 0x08, 0xd6, 0xba, 0xdf, 0x7f, 0x16, 0x85, 0xcc, 0x99, 0x07, 0x33,
	0x0c, 0x24, 0x97, 0x19, 0x06, 0x4e, 0x03, 0x8c, 0xd7, 0x9c, 0xba, 0x42, 0x8c, 0xd7, 0x08, 0x8d,
	0xb8, 0xff, 0x15, 0x62, 0x8c, 0x9c, 0x26, 0x58, 0x6c, 0x6f, 0x10, 0x05, 0x34, 0x69, 0x96, 0x39,
	0x4e, 0x81, 0xce, 0x22, 0xd4, 0x58, 0xd8, 0xa5, 0xbc, 0x14, 0x2a, 0x3c, 0x81, 0xb6, 0xb7, 0x25,
	0x11, 0x24, 0x3b, 0x72, 0xff, 0x32, 0xa0, 0xbc, 0xee, 0xf7, 0x53, 0x34, 0x6c, 0x27, 0x4c, 0xd8,
	0xde, 0x0b, 0xa9, 0x59, 0x42, 0x19, 0xfe, 0xa5, 0x34, 0x41, 0x42, 0x98, 0x0e, 0x96, 0x50, 0x3f,
	0x1d, 0x24, 0x54, 0x9a, 0x93, 0xc1, 0x58, 0x63, 0x51, 0xfc, 0xea, 0x85, 0x34, 0x89, 0x7f, 0x4b,
	0xdc, 0x4b, 0x6e, 0x8b, 0xc0, 0xbd, 0x74, 0x5a, 0x50, 0xe9, 0x24, 0x61, 0x90, 0x36, 0xab, 0x0b,
	0xa5, 0xa5, 0xfa, 0xcd, 0x9a, 0x27, 0x43, 0x40, 0x04, 0xda, 0x69, 0x01, 0x24, 0x74, 0x4b, 0x69,
	0xb1, 0x38, 0xa7, 0x86, 0x71, 0x01, 0x6a, 0x0f, 0x23, 0x46, 0x13, 0x42, 0x0f, 0xdc, 0xff, 0x4c,
	0x09, 0x60, 0xeb, 0xcd, 0x83, 0xd9, 0x1d, 0xaa, 0x10, 0x76, 0x87, 0xa8, 0xbc, 0x13, 0x77, 0x03,
	0xee, 0x82, 0x41, 0xf8, 0xb7, 0x73, 0x0e, 0xca, 0x3d, 0xbf, 0x9f, 0x72, 0xe3, 0xeb, 0x37, 0x2b,
	0xa8, 0x3b, 0x25, 0x1c, 0x85, 0xbe, 0xa5, 0x2c, 0xa1, 0x51, 0x87, 0xed, 0x49, 0x1f, 0x32, 0x98,
	0xf7, 0x0f, 0xf5, 0x03, 0xee, 0x47, 0x8d, 0xf0, 0x6f, 0xc7, 0x85, 0xc6, 0x6e, 0x42, 0x29, 0xa1,
	0x29, 0x65, 0xeb, 0x7e, 0xbf, 0x59, 0xe5, 0x67, 0x05, 0x1c, 0xf2, 0xed, 0x21, 0x9f, 0x25, 0xfa,
	0x0e, 0xbf, 0x31, 0x7b, 0x41, 0xe8, 0xf7, 0xe2, 0x28, 0x68, 0xd6, 0x44, 0xf6, 0x24, 0xe8, 0x5c,
	0x84, 0x72, 0xba, 0x17, 0xf7, 0x9b, 0x36, 0x0f, 0x8c, 0xed, 0x3d, 0xdd, 0x8b, 0x45, 0x64, 0x38,
	0xda, 0x59, 0x84, 0x79, 0xfa, 0x9a, 0x25, 0xfe, 0x76, 0x66, 0x26, 0x70, 0xfe, 0x39, 0x8e, 0x7d,
	0xaa, 0x6c, 0xbd, 0x04, 0xd5, 0x3d, 0x3f, 0x65, 0x34, 0x6a, 0xd6, 0xb9, 0x93, 0x96, 0xf7, 0x88,
	0x83, 0x44, 0xa2, 0x9d, 0x6b, 0x50, 0x4b, 0x68, 0xf0, 0x24, 0x0e, 0x23, 0xd6, 0x6c, 0x70, 0x55,
	0x73, 0x1e, 0x91, 0x08, 0xae, 0x2e, 0x3b, 0x46, 0x5b, 0x3b, 0x83, 0xb0, 0x1b, 0xac, 0x06, 0xcd,
	0x39, 0xde, 0xad, 0x0a, 0x74, 0x17, 0xc1, 0x5a, 0x8f, 0x87, 0x14, 0x3b, 0x83, 0x97, 0xaa, 0x51,
	0x28, 0x55, 0x59, 0xb8, 0x23, 0x45, 0x86, 0xad, 0x71, 0x14, 0xd9, 0x35, 0xa8, 0x6f, 0xf6, 0x69,
	0xf4, 0xad, 0xdf, 0xed, 0x1e, 0x27, 0xf1, 0x77, 0x23, 0xa7, 0x45, 0xb1, 0x7a, 0xda, 0x8c, 0xf1,
	0xb4, 0x8d, 0x55, 0x80, 0x4a, 0x65, 0x49, 0x4b, 0x65, 0x56, 0x92, 0xe5, 0xc9, 0x25, 0x89, 0x73,
	0x2d, 0xdd, 0x1c, 0xd2, 0x44, 0x16, 0x80, 0x84, 0x26, 0x64, 0xa4, 0x3a, 0x21, 0x23, 0xee, 0x27,
	0x30, 0xbf, 0x42, 0x99, 0x2a, 0xe0, 0xe3, 0x1c, 0xbc, 0x5a, 0xa0, 0x46, 0x17, 0x95, 0x1b, 0x46,
	0xee, 0x86, 0x7b, 0x03, 0x4e, 0x61, 0x14, 0x4e, 0x2a, 0x74, 0xbb, 0x48, 0x3e, 0x45, 0xaa, 0x73,
	0x01, 0xca, 0xe8, 0x31, 0xe7, 0xd3, 0xe3, 0xc0, 0xb1, 0x47, 0x75, 0x3f, 0xde, 0xa3, 0x84, 0x0e,
	0x43, 0x5e, 0x11, 0xee, 0x1b, 0x43, 0x41, 0x52, 0x11, 0x8f, 0xb8, 0xa1, 0x45, 0x5c, 0xcf, 0x9a,
	0x79, 0x28, 0x6b, 0xca, 0x88, 0xd2, 0x44, 0x23, 0xde, 0xd7, 0x98, 0x19, 0xcf, 0x9d, 0x35, 0x29,
	0x77, 0x73, 0x50, 0x57, 0xdd, 0x8c, 0x9e, 0xfd, 0x62, 0xe4, 0xf0, 0x71, 0xd5, 0xa7, 0x66, 0x8d,
	0x39, 0x3e, 0x6b, 0x0e, 0xcf, 0x8e, 0xd2, 0x84, 0xd9, 0x31, 0x6e, 0x60, 0x79, 0x92, 0x81, 0x36,
	0x58, 0xcf, 0xfa, 0x6b, 0x43, 0x34, 0xee, 0x1b, 0xf1, 0x89, 0x76, 0x9d, 0x64, 0x16, 0x9e, 0xc0,
	0x08, 0xf7, 0x09, 0xd4, 0x95, 0x26, 0x1c, 0xb1, 0x47, 0xb9, 0x3b, 0x6e, 0xaf, 0x39, 0xc9, 0xde,
	0x35, 0xb0, 0x57, 0xa3, 0x76, 0xdc, 0xa3, 0x28, 0x6f, 0x52, 0x0d, 0x5e, 0x07, 0x08, 0x39, 0x01,
	0xbf, 0xc5, 0x4c, 0x7e, 0x8b, 0xd5, 0xbd, 0xd5, 0x0c, 0x45, 0xb4, 0x63, 0xf7, 0x39, 0xc0, 0xb2,
	0x98, 0x9e, 0x28, 0x4e, 0x1b, 0xad, 0x46, 0x71, 0xb4, 0x7a, 0x50, 0x97, 0x9f, 0x9a, 0xd4, 0x86,
	0xb7, 0x9c, 0xe3, 0x88, 0x4e, 0x80, 0x51, 0x7d, 0xe0, 0x27, 0x01, 0x46, 0xf5, 0x47, 0xf1, 0x89,
	0x51, 0xfd, 0x48, 0xae, 0x51, 0x06, 0x2f, 0x29, 0xc7, 0x93, 0x78, 0x0f, 0x97, 0x9f, 0x87, 0x11,
	0x4b, 0x46, 0x62, 0xb5, 0x3a, 0x7f, 0x0b, 0xec, 0x0c, 0xe5, 0x9c, 0x86, 0xd2, 0x3e, 0x1d, 0x49,
	0x83, 0xf0, 0x13, 0x97, 0x84, 0xa1, 0xdf, 0x1d, 0x50, 0x19, 0x20, 0x01, 0x7c, 0x65, 0xde, 0x36,
	0x94, 0x2e, 0xf4, 0x65, 0x92, 0xae, 0x0d, 0xb6, 0xfb, 0xfe, 0x74, 0xad, 0x43, 0x1d, 0x65, 0xca,
	0xe2, 0x19, 0x5b, 0x40, 0x3c, 0xa8, 0xb7, 0xe3, 0x28, 0x1d, 0x14, 0xf2, 0xd0, 0xf0, 0x1e, 0xe4,
	0x38, 0xa2, 0x13, 0xb8, 0x37, 0x72, 0x71, 0xb2, 0x00, 0x0b, 0xe2, 0x44, 0x41, 0x9a, 0xaa, 0x20,
	0xdd, 0x4d, 0xa8, 0xa9, 0xeb, 0xcd, 0xb9, 0x0e, 0x75, 0xbc, 0xe0, 0xee, 0x0f, 0x46, 0xda, 0x0e,
	0x2b, 0xae, 0x3f, 0xa1, 0x47, 0x3b, 0xe5, 0xab, 0xc9, 0x60, 0xb4, 0x31, 0xe8, 0x65, 0xab, 0x09,
	0x87, 0xdc, 0xab, 0x00, 0x4f, 0x05, 0x19, 0x7a, 0x73, 0x16, 0xaa, 0xc8, 0xb4, 0xaa, 0x4c, 0x90,
	0x90, 0xfb, 0x9b, 0x91, 0x91, 0xc9, 0x65, 0x74, 0x12, 0x99, 0x5e, 0x48, 0x66, 0xb1, 0x90, 0xf4,
	0x0e, 0x28, 0x1d, 0xea, 0x80, 0x8b, 0x50, 0x0e, 0xa3, 0xdd, 0x98, 0xf7, 0x69, 0xf1, 0xfe, 0x46,
	0xf4, 0x84, 0x06, 0xa9, 0x4c, 0x6a, 0x90, 0x03, 0x00, 0x71, 0x61, 0xcb, 0xd8, 0x80, 0xb8, 0xb6,
	0xb5, 0xd0, 0xd4, 0xe5, 0x8d, 0x2e, 0xba, 0x21, 0x3f, 0x76, 0x2e, 0x80, 0x9d, 0x32, 0x3f, 0x61,
	0x5b, 0x61, 0x4f, 0x64, 0xac, 0x44, 0x72, 0x04, 0x3a, 0x45, 0xa3, 0x80, 0x9f, 0x95, 0xf8, 0x99,
	0x02, 0xdd, 0x15, 0xa8, 0x0a, 0x89, 0xce, 0x95, 0x6c, 0x79, 0x10, 0x75, 0xa7, 0x54, 0x71, 0x37,
	0xd4, 0x02, 0xa1, 0x09, 0x32, 0x8b, 0x82, 0x6e, 0x83, 0x2d, 0x97, 0x0d, 0x7a, 0x30, 0x93, 0xe9,
	0xee, 0x63, 0xc5, 0x89, 0x69, 0xd1, 0xad, 0x30, 0x66, 0xb7, 0xe2, 0x0f, 0x03, 0x60, 0x95, 0xbf,
	0x3c, 0x78, 0x08, 0x4f, 0x43, 0x69, 0x20, 0x6b, 0xb1, 0x4c, 0xf0, 0x33, 0x5b, 0xcb, 0x4c, 0x6d,
	0x2d, 0xbb, 0x08, 0xb0, 0x1b, 0x26, 0x29, 0xdb, 0x8e, 0x7c, 0x19, 0x20, 0x9b, 0xd8, 0x1c, 0xb3,
	0xe1, 0xf7, 0xa8, 0xf3, 0x21, 0xd8, 0x5d, 0x5f, 0x9d, 0x96, 0xe5, 0x4b, 0xc4, 0xcf, 0x0f, 0xf1,
	0x15, 0x23, 0x0e, 0x2b, 0xe2, 0x10, 0x11, 0xfc, 0x50, 0x54, 0x7e, 0x35, 0x1b, 0xc5, 0x5a, 0x6d,
	0x59, 0x85, 0xda, 0xc2, 0x3b, 0x54, 0x98, 0x8d, 0x63, 0xe7, 0x07, 0x05, 0x60, 0x40, 0x9a, 0x60,
	0x25, 0xf4, 0x95, 0x9f, 0x04, 0x29, 0xcf, 0x4b, 0x85, 0x28, 0xd0, 0x59, 0x04, 0x4b, 0x3c, 0xb2,
	0xf0, 0x9e, 0x11, 0x19, 0xcb, 0x5d, 0x27, 0xea, 0x0c, 0x3d, 0xde, 0xed, 0xfa, 0x1d, 0xb5, 0xf5,
	0xe0, 0xb7, 0x7b, 0x19, 0x4e, 0x29, 0x75, 0xaf, 0xc4, 0xac, 0x3b, 0xdc, 0xb5, 0x87, 0x49, 0x26,
	0x34, 0xb6, 0xfb, 0xb1, 0xb2, 0x53, 0xde, 0x0f, 0x42, 0x23, 0x4d, 0x65, 0xbc, 0x33, 0xd8, 0x7d,
	0x86, 0x4f, 0xa5, 0x7c, 0xcb, 0x74, 0x3e, 0x85, 0x86, 0xda, 0x33, 0xb5, 0x02, 0xc9, 0x57, 0x51,
	0x5e, 0x22, 0x05, 0x92, 0xcc, 0x0b, 0x53, 0xf3, 0xe2, 0x2e, 0x5e, 0xc8, 0x82, 0x06, 0x3d, 0x98,
	0x5d, 0xaa, 0x7b, 0x3b, 0x97, 0x80, 0x0e, 0xea, 0xeb, 0xb1, 0x28, 0xbf, 0x69, 0xeb, 0xb1, 0xce,
	0x89, 0xde, 0x17, 0x39, 0x8f, 0x5a, 0xac, 0xdd, 0x3f, 0x0d, 0xa8, 0x11, 0x3f, 0xda, 0x9f, 0x52,
	0xa0, 0x98, 0x6f, 0x3f, 0xda, 0x0f, 0xa3, 0x8e, 0x9a, 0x3f, 0x12, 0xcc, 0x4a, 0xb7, 0x34, 0xb5,
	0x74, 0xcb, 0x47, 0x96, 0x6e, 0xe5, 0xa8, 0xd2, 0xad, 0x1e, 0x2a, 0x5d, 0x75, 0x3d, 0x5b, 0xda,
	0xe2, 0x79, 0x17, 0x2c, 0x34, 0x1c, 0x63, 0xbd, 0x08, 0x35, 0x34, 0xab, 0x30, 0xb4, 0x89, 0x44,
	0x90, 0xec, 0x68, 0x6c, 0xf4, 0xff, 0x24, 0x24, 0x60, 0xac, 0xdf, 0x4d, 0x02, 0x0e, 0xda, 0x6e,
	0x98, 0xb2, 0x66, 0x49, 0x3e, 0x94, 0x54, 0x24, 0x09, 0x47, 0x3b, 0xe7, 0xc0, 0x94, 0x71, 0x28,
	0x1c, 0x9a, 0x3d, 0xea, 0xfe, 0x0c, 0xf6, 0x0a, 0xbe, 0x60, 0x78, 0xdc, 0xb5, 0xd7, 0x8d, 0x51,
	0x78, 0xdd, 0x1c, 0x1d, 0x7f, 0x6d, 0x40, 0xf0, 0x6f, 0xbc, 0x45, 0x7a, 0xb4, 0xb7, 0x93, 0x3d,
	0xc7, 0x25, 0x94, 0x85, 0xaf, 0xa2, 0x85, 0xef, 0x73, 0x68, 0x70, 0x03, 0xd6, 0xc2, 0x94, 0x9d,
	0x3c, 0x86, 0xd8, 0x3c, 0x19, 0xdb, 0x0c, 0x81, 0x6b, 0xc9, 0x40, 0x89, 0xd1, 0x00, 0x5e, 0xe6,
	0xbb, 0x88, 0x94, 0xbb, 0x29, 0xc5, 0xce, 0x98, 0x51, 0x2d, 0x70, 0x66, 0xf1, 0x59, 0x18, 0x69,
	0x02, 0x67, 0xb0, 0x73, 0xaa, 0xc0, 0x63, 0x52, 0xed, 0x2e, 0x49, 0x7d, 0x8f, 0x63, 0xf1, 0xf7,
	0x6a, 0x6a, 0x4a, 0x0b, 0x94, 0x72, 0xa4, 0x4e, 0xa1, 0x3c, 0x05, 0x73, 0x22, 0xd6, 0xd4, 0x17,
	0xcf, 0x99, 0x2b, 0x3a, 0x42, 0xbe, 0x68, 0xf8, 0x1c, 0x32, 0xf2, 0x39, 0x74, 0xff, 0xcc, 0x9b,
	0xb7, 0x2d, 0xe3, 0xef, 0xb7, 0x2d, 0xe3, 0x9f, 0xb7, 0x2d, 0xe3, 0xd7, 0x7f, 0x5b, 0x1f, 0x7c,
	0x67, 0xf6, 0x77, 0x76, 0xaa, 0xfc, 0x2f, 0xe3, 0x67, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0xf4,
	0x0b, 0x3d, 0x4a, 0x82, 0x14, 0x00, 0x00,
}

func (m *Heartbeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Heartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Heartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *KickNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KickNtf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KickNtf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.ErrNo != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ErrNo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ErrNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrNtf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrNtf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.ErrNo != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ErrNo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GmReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GmReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GmReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.GmType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.GmType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GmAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GmAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GmAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.GmType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.GmType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *LoginReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Invite != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Invite))
		i--
		dAtA[i] = 0x18
	}
	if len(m.InitData) > 0 {
		i -= len(m.InitData)
		copy(dAtA[i:], m.InitData)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.InitData)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoginAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LinkAddr) > 0 {
		i -= len(m.LinkAddr)
		copy(dAtA[i:], m.LinkAddr)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.LinkAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserID != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VerifyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.ErrNo != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ErrNo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReconnectReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReconnectReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReconnectReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReconnectAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReconnectAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReconnectAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.ErrNo != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ErrNo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MapUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MapUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TileType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.TileType))
		i--
		dAtA[i] = 0x28
	}
	if m.Thunder != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Thunder))
		i--
		dAtA[i] = 0x20
	}
	if m.Y != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x18
	}
	if m.X != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Maps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Maps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Maps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReTreasure != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ReTreasure))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Grids) > 0 {
		for iNdEx := len(m.Grids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Grids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.NowY != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.NowY))
		i--
		dAtA[i] = 0x28
	}
	if m.NowX != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.NowX))
		i--
		dAtA[i] = 0x20
	}
	if m.Treasure != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Treasure))
		i--
		dAtA[i] = 0x18
	}
	if m.BirthY != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.BirthY))
		i--
		dAtA[i] = 0x10
	}
	if m.BirthX != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.BirthX))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnterReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnterReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnterReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *EnterNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnterNtf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnterNtf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GuildId != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.GuildId))
		i--
		dAtA[i] = 0x68
	}
	if len(m.RedPoint) > 0 {
		for iNdEx := len(m.RedPoint) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RedPoint[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.Hasten != nil {
		{
			size, err := m.Hasten.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.ExtraStrength != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ExtraStrength))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Shop) > 0 {
		for iNdEx := len(m.Shop) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shop[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Diamond != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Diamond))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Head) > 0 {
		i -= len(m.Head)
		copy(dAtA[i:], m.Head)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.Head)))
		i--
		dAtA[i] = 0x3a
	}
	if m.FreeResetMap {
		i--
		if m.FreeResetMap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Dead {
		i--
		if m.Dead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Strength != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Strength))
		i--
		dAtA[i] = 0x20
	}
	if m.Maps != nil {
		{
			size, err := m.Maps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Gold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Gold))))
		i--
		dAtA[i] = 0x11
	}
	if m.Lv != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Lv))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MoveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoveReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Y != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MoveAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoveAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Y != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpenWallReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenWallReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenWallReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Y != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpenWallAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenWallAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenWallAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExtraStrength != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ExtraStrength))
		i--
		dAtA[i] = 0x30
	}
	if m.IsOver {
		i--
		if m.IsOver {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Grids) > 0 {
		for iNdEx := len(m.Grids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Grids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Dead {
		i--
		if m.Dead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Gold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Gold))))
		i--
		dAtA[i] = 0x11
	}
	if m.Strength != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Strength))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTreasureReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTreasureReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTreasureReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Y != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTreasureAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTreasureAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTreasureAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Gold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Gold))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *OpenTreasureReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenTreasureReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenTreasureReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Y != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpenTreasureAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenTreasureAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenTreasureAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Treasure != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Treasure))
		i--
		dAtA[i] = 0x18
	}
	if m.Grid != nil {
		{
			size, err := m.Grid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Gold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Gold))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ReviveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReviveReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReviveReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ReviveAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReviveAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReviveAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExtraStrength != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ExtraStrength))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Grids) > 0 {
		for iNdEx := len(m.Grids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Grids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.NowY != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.NowY))
		i--
		dAtA[i] = 0x28
	}
	if m.NowX != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.NowX))
		i--
		dAtA[i] = 0x20
	}
	if m.Grid != nil {
		{
			size, err := m.Grid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Strength != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Strength))
		i--
		dAtA[i] = 0x10
	}
	if m.Dead {
		i--
		if m.Dead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResetMapReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetMapReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetMapReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ResetMapAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetMapAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetMapAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExtraStrength != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ExtraStrength))
		i--
		dAtA[i] = 0x20
	}
	if m.FreeResetMap {
		i--
		if m.FreeResetMap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Maps != nil {
		{
			size, err := m.Maps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Strength != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Strength))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpLvReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpLvReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpLvReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpLvAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpLvAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpLvAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FreeResetMap {
		i--
		if m.FreeResetMap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Gold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Gold))))
		i--
		dAtA[i] = 0x11
	}
	if m.Lv != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Lv))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StrengthNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StrengthNtf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StrengthNtf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExtraStrength != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ExtraStrength))
		i--
		dAtA[i] = 0x10
	}
	if m.Strength != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Strength))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IncomeNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomeNtf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncomeNtf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IncomeType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.IncomeType))
		i--
		dAtA[i] = 0x10
	}
	if m.Gold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Gold))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DiamondNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiamondNtf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiamondNtf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DiamondType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.DiamondType))
		i--
		dAtA[i] = 0x10
	}
	if m.Diamond != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Diamond))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CardAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for k := range m.Data {
			v := m.Data[k]
			baseI := i
			i = encodeVarintCMsg(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintCMsg(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCMsg(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CardNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardNtf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardNtf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for k := range m.Data {
			v := m.Data[k]
			baseI := i
			i = encodeVarintCMsg(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintCMsg(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCMsg(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CardUpLvReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardUpLvReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardUpLvReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConsumeType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ConsumeType))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CardUpLvAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardUpLvAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardUpLvAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lv != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Lv))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShopUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShopUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BuyNum != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.BuyNum))
		i--
		dAtA[i] = 0x10
	}
	if m.ShopBuyType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ShopBuyType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShopBuyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopBuyReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShopBuyReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShopId != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ShopId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShopBuyAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopBuyAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShopBuyAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExtraStrength != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ExtraStrength))
		i--
		dAtA[i] = 0x28
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Strength != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Strength))
		i--
		dAtA[i] = 0x18
	}
	if m.Diamond != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Diamond))
		i--
		dAtA[i] = 0x10
	}
	if m.ShopId != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.ShopId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HastenUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HastenUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HastenUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndTime != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x18
	}
	if m.StartTime != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x10
	}
	if m.HastenType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.HastenType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Hasten) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Hasten) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Hasten) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndTime != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hasten) > 0 {
		for iNdEx := len(m.Hasten) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Hasten[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HastenReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HastenReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HastenReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HastenType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.HastenType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HastenAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HastenAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HastenAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndTime != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x10
	}
	if m.Hasten != nil {
		{
			size, err := m.Hasten.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InviteUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InviteUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InviteUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Diamond != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Diamond))
		i--
		dAtA[i] = 0x38
	}
	if m.Lv != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Lv))
		i--
		dAtA[i] = 0x30
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Head) > 0 {
		i -= len(m.Head)
		copy(dAtA[i:], m.Head)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.Head)))
		i--
		dAtA[i] = 0x12
	}
	if m.Uid != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InviteReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InviteReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InviteReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *InviteAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InviteAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InviteAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flag {
		i--
		if m.Flag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Invites) > 0 {
		for iNdEx := len(m.Invites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Invites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Rewards) > 0 {
		dAtA9 := make([]byte, len(m.Rewards)*10)
		var j8 int
		for _, num1 := range m.Rewards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintCMsg(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InviteRewardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InviteRewardReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InviteRewardReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InviteRewardAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InviteRewardAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InviteRewardAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InviteNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InviteNtf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InviteNtf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Invitees != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Invitees))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RedPointUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedPointUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedPointUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flag {
		i--
		if m.Flag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.RedPointType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.RedPointType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RedPointReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedPointReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedPointReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RedPointType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.RedPointType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RedPointAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedPointAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedPointAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RedPoint != nil {
		{
			size, err := m.RedPoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RedPointNtf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedPointNtf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedPointNtf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RedPoint) > 0 {
		for iNdEx := len(m.RedPoint) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RedPoint[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RankUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Gold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Gold))))
		i--
		dAtA[i] = 0x39
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Head) > 0 {
		i -= len(m.Head)
		copy(dAtA[i:], m.Head)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.Head)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ranking != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Ranking))
		i--
		dAtA[i] = 0x10
	}
	if m.Uid != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lv != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Lv))
		i--
		dAtA[i] = 0x10
	}
	if m.RankType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.RankType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RankAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RankAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RankAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Me != nil {
		{
			size, err := m.Me.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Lv != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Lv))
		i--
		dAtA[i] = 0x10
	}
	if m.RankType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.RankType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GuildUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Gold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Gold))))
		i--
		dAtA[i] = 0x29
	}
	if m.Member != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Member))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ranking != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.Ranking))
		i--
		dAtA[i] = 0x10
	}
	if m.GuildId != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.GuildId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GuildListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RankType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.RankType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GuildListAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildListAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildListAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.RankType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.RankType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GuildRankReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildRankReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildRankReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GuildId != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.GuildId))
		i--
		dAtA[i] = 0x10
	}
	if m.RankType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.RankType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GuildRankAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildRankAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildRankAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.GuildId != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.GuildId))
		i--
		dAtA[i] = 0x10
	}
	if m.RankType != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.RankType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GuildJoinReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildJoinReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildJoinReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GuildId != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.GuildId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GuildJoinAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildJoinAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildJoinAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GuildId != 0 {
		i = encodeVarintCMsg(dAtA, i, uint64(m.GuildId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GuildLeaveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildLeaveReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildLeaveReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GuildLeaveAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildLeaveAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildLeaveAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flag {
		i--
		if m.Flag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCMsg(dAtA []byte, offset int, v uint64) int {
	offset -= sovCMsg(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Heartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KickNtf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrNo != 0 {
		n += 1 + sovCMsg(uint64(m.ErrNo))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ErrNtf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrNo != 0 {
		n += 1 + sovCMsg(uint64(m.ErrNo))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GmReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GmType != 0 {
		n += 1 + sovCMsg(uint64(m.GmType))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GmAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GmType != 0 {
		n += 1 + sovCMsg(uint64(m.GmType))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TestMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoginReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCMsg(uint64(m.Type))
	}
	l = len(m.InitData)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.Invite != 0 {
		n += 1 + sovCMsg(uint64(m.Invite))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoginAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovCMsg(uint64(m.UserID))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	l = len(m.LinkAddr)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrNo != 0 {
		n += 1 + sovCMsg(uint64(m.ErrNo))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReconnectReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReconnectAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrNo != 0 {
		n += 1 + sovCMsg(uint64(m.ErrNo))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MapUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCMsg(uint64(m.Id))
	}
	if m.X != 0 {
		n += 1 + sovCMsg(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovCMsg(uint64(m.Y))
	}
	if m.Thunder != 0 {
		n += 1 + sovCMsg(uint64(m.Thunder))
	}
	if m.TileType != 0 {
		n += 1 + sovCMsg(uint64(m.TileType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Maps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BirthX != 0 {
		n += 1 + sovCMsg(uint64(m.BirthX))
	}
	if m.BirthY != 0 {
		n += 1 + sovCMsg(uint64(m.BirthY))
	}
	if m.Treasure != 0 {
		n += 1 + sovCMsg(uint64(m.Treasure))
	}
	if m.NowX != 0 {
		n += 1 + sovCMsg(uint64(m.NowX))
	}
	if m.NowY != 0 {
		n += 1 + sovCMsg(uint64(m.NowY))
	}
	if len(m.Grids) > 0 {
		for _, e := range m.Grids {
			l = e.Size()
			n += 1 + l + sovCMsg(uint64(l))
		}
	}
	if m.ReTreasure != 0 {
		n += 1 + sovCMsg(uint64(m.ReTreasure))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnterReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnterNtf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovCMsg(uint64(m.Lv))
	}
	if m.Gold != 0 {
		n += 9
	}
	if m.Maps != nil {
		l = m.Maps.Size()
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.Strength != 0 {
		n += 1 + sovCMsg(uint64(m.Strength))
	}
	if m.Dead {
		n += 2
	}
	if m.FreeResetMap {
		n += 2
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.Diamond != 0 {
		n += 1 + sovCMsg(uint64(m.Diamond))
	}
	if len(m.Shop) > 0 {
		for _, e := range m.Shop {
			l = e.Size()
			n += 1 + l + sovCMsg(uint64(l))
		}
	}
	if m.ExtraStrength != 0 {
		n += 1 + sovCMsg(uint64(m.ExtraStrength))
	}
	if m.Hasten != nil {
		l = m.Hasten.Size()
		n += 1 + l + sovCMsg(uint64(l))
	}
	if len(m.RedPoint) > 0 {
		for _, e := range m.RedPoint {
			l = e.Size()
			n += 1 + l + sovCMsg(uint64(l))
		}
	}
	if m.GuildId != 0 {
		n += 1 + sovCMsg(uint64(m.GuildId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MoveReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovCMsg(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovCMsg(uint64(m.Y))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MoveAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovCMsg(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovCMsg(uint64(m.Y))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenWallReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovCMsg(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovCMsg(uint64(m.Y))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenWallAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Strength != 0 {
		n += 1 + sovCMsg(uint64(m.Strength))
	}
	if m.Gold != 0 {
		n += 9
	}
	if m.Dead {
		n += 2
	}
	if len(m.Grids) > 0 {
		for _, e := range m.Grids {
			l = e.Size()
			n += 1 + l + sovCMsg(uint64(l))
		}
	}
	if m.IsOver {
		n += 2
	}
	if m.ExtraStrength != 0 {
		n += 1 + sovCMsg(uint64(m.ExtraStrength))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTreasureReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovCMsg(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovCMsg(uint64(m.Y))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTreasureAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gold != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenTreasureReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovCMsg(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovCMsg(uint64(m.Y))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenTreasureAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gold != 0 {
		n += 9
	}
	if m.Grid != nil {
		l = m.Grid.Size()
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.Treasure != 0 {
		n += 1 + sovCMsg(uint64(m.Treasure))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReviveReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReviveAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dead {
		n += 2
	}
	if m.Strength != 0 {
		n += 1 + sovCMsg(uint64(m.Strength))
	}
	if m.Grid != nil {
		l = m.Grid.Size()
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.NowX != 0 {
		n += 1 + sovCMsg(uint64(m.NowX))
	}
	if m.NowY != 0 {
		n += 1 + sovCMsg(uint64(m.NowY))
	}
	if len(m.Grids) > 0 {
		for _, e := range m.Grids {
			l = e.Size()
			n += 1 + l + sovCMsg(uint64(l))
		}
	}
	if m.ExtraStrength != 0 {
		n += 1 + sovCMsg(uint64(m.ExtraStrength))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetMapReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetMapAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Strength != 0 {
		n += 1 + sovCMsg(uint64(m.Strength))
	}
	if m.Maps != nil {
		l = m.Maps.Size()
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.FreeResetMap {
		n += 2
	}
	if m.ExtraStrength != 0 {
		n += 1 + sovCMsg(uint64(m.ExtraStrength))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpLvReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpLvAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lv != 0 {
		n += 1 + sovCMsg(uint64(m.Lv))
	}
	if m.Gold != 0 {
		n += 9
	}
	if m.FreeResetMap {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StrengthNtf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Strength != 0 {
		n += 1 + sovCMsg(uint64(m.Strength))
	}
	if m.ExtraStrength != 0 {
		n += 1 + sovCMsg(uint64(m.ExtraStrength))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IncomeNtf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gold != 0 {
		n += 9
	}
	if m.IncomeType != 0 {
		n += 1 + sovCMsg(uint64(m.IncomeType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiamondNtf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Diamond != 0 {
		n += 1 + sovCMsg(uint64(m.Diamond))
	}
	if m.DiamondType != 0 {
		n += 1 + sovCMsg(uint64(m.DiamondType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CardAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCMsg(uint64(k)) + 1 + sovCMsg(uint64(v))
			n += mapEntrySize + 1 + sovCMsg(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CardNtf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCMsg(uint64(k)) + 1 + sovCMsg(uint64(v))
			n += mapEntrySize + 1 + sovCMsg(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CardUpLvReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCMsg(uint64(m.Id))
	}
	if m.ConsumeType != 0 {
		n += 1 + sovCMsg(uint64(m.ConsumeType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CardUpLvAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCMsg(uint64(m.Id))
	}
	if m.Lv != 0 {
		n += 1 + sovCMsg(uint64(m.Lv))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShopUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopBuyType != 0 {
		n += 1 + sovCMsg(uint64(m.ShopBuyType))
	}
	if m.BuyNum != 0 {
		n += 1 + sovCMsg(uint64(m.BuyNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShopBuyReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopId != 0 {
		n += 1 + sovCMsg(uint64(m.ShopId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShopBuyAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopId != 0 {
		n += 1 + sovCMsg(uint64(m.ShopId))
	}
	if m.Diamond != 0 {
		n += 1 + sovCMsg(uint64(m.Diamond))
	}
	if m.Strength != 0 {
		n += 1 + sovCMsg(uint64(m.Strength))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.ExtraStrength != 0 {
		n += 1 + sovCMsg(uint64(m.ExtraStrength))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HastenUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HastenType != 0 {
		n += 1 + sovCMsg(uint64(m.HastenType))
	}
	if m.StartTime != 0 {
		n += 1 + sovCMsg(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovCMsg(uint64(m.EndTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Hasten) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Hasten) > 0 {
		for _, e := range m.Hasten {
			l = e.Size()
			n += 1 + l + sovCMsg(uint64(l))
		}
	}
	if m.EndTime != 0 {
		n += 1 + sovCMsg(uint64(m.EndTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HastenReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HastenType != 0 {
		n += 1 + sovCMsg(uint64(m.HastenType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HastenAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hasten != nil {
		l = m.Hasten.Size()
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.EndTime != 0 {
		n += 1 + sovCMsg(uint64(m.EndTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InviteUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovCMsg(uint64(m.Uid))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.Lv != 0 {
		n += 1 + sovCMsg(uint64(m.Lv))
	}
	if m.Diamond != 0 {
		n += 1 + sovCMsg(uint64(m.Diamond))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InviteReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InviteAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rewards) > 0 {
		l = 0
		for _, e := range m.Rewards {
			l += sovCMsg(uint64(e))
		}
		n += 1 + sovCMsg(uint64(l)) + l
	}
	if len(m.Invites) > 0 {
		for _, e := range m.Invites {
			l = e.Size()
			n += 1 + l + sovCMsg(uint64(l))
		}
	}
	if m.Flag {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InviteRewardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCMsg(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InviteRewardAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCMsg(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InviteNtf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Invitees != 0 {
		n += 1 + sovCMsg(uint64(m.Invitees))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RedPointUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RedPointType != 0 {
		n += 1 + sovCMsg(uint64(m.RedPointType))
	}
	if m.Flag {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RedPointReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RedPointType != 0 {
		n += 1 + sovCMsg(uint64(m.RedPointType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RedPointAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RedPoint != nil {
		l = m.RedPoint.Size()
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RedPointNtf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RedPoint) > 0 {
		for _, e := range m.RedPoint {
			l = e.Size()
			n += 1 + l + sovCMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovCMsg(uint64(m.Uid))
	}
	if m.Ranking != 0 {
		n += 1 + sovCMsg(uint64(m.Ranking))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.Gold != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankType != 0 {
		n += 1 + sovCMsg(uint64(m.RankType))
	}
	if m.Lv != 0 {
		n += 1 + sovCMsg(uint64(m.Lv))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RankAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankType != 0 {
		n += 1 + sovCMsg(uint64(m.RankType))
	}
	if m.Lv != 0 {
		n += 1 + sovCMsg(uint64(m.Lv))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCMsg(uint64(l))
		}
	}
	if m.Me != nil {
		l = m.Me.Size()
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GuildId != 0 {
		n += 1 + sovCMsg(uint64(m.GuildId))
	}
	if m.Ranking != 0 {
		n += 1 + sovCMsg(uint64(m.Ranking))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCMsg(uint64(l))
	}
	if m.Member != 0 {
		n += 1 + sovCMsg(uint64(m.Member))
	}
	if m.Gold != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankType != 0 {
		n += 1 + sovCMsg(uint64(m.RankType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildListAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankType != 0 {
		n += 1 + sovCMsg(uint64(m.RankType))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildRankReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankType != 0 {
		n += 1 + sovCMsg(uint64(m.RankType))
	}
	if m.GuildId != 0 {
		n += 1 + sovCMsg(uint64(m.GuildId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildRankAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankType != 0 {
		n += 1 + sovCMsg(uint64(m.RankType))
	}
	if m.GuildId != 0 {
		n += 1 + sovCMsg(uint64(m.GuildId))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildJoinReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GuildId != 0 {
		n += 1 + sovCMsg(uint64(m.GuildId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildJoinAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GuildId != 0 {
		n += 1 + sovCMsg(uint64(m.GuildId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildLeaveReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildLeaveAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flag {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCMsg(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCMsg(x uint64) (n int) {
	return sovCMsg(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Heartbeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Heartbeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Heartbeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KickNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KickNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KickNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			m.ErrNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			m.ErrNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GmReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GmReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GmReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GmType", wireType)
			}
			m.GmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GmType |= GmType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GmAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GmAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GmAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GmType", wireType)
			}
			m.GmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GmType |= GmType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LoginType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invite", wireType)
			}
			m.Invite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Invite |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			m.ErrNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReconnectReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReconnectReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReconnectReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReconnectAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReconnectAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReconnectAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrNo", wireType)
			}
			m.ErrNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thunder", wireType)
			}
			m.Thunder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Thunder |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TileType", wireType)
			}
			m.TileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TileType |= TileType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Maps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Maps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Maps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BirthX", wireType)
			}
			m.BirthX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BirthX |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BirthY", wireType)
			}
			m.BirthY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BirthY |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Treasure", wireType)
			}
			m.Treasure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Treasure |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowX", wireType)
			}
			m.NowX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowX |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowY", wireType)
			}
			m.NowY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowY |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grids = append(m.Grids, &MapUnit{})
			if err := m.Grids[len(m.Grids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReTreasure", wireType)
			}
			m.ReTreasure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReTreasure |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnterReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnterReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnterReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnterNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnterNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnterNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gold = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Maps == nil {
				m.Maps = &Maps{}
			}
			if err := m.Maps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dead = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeResetMap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FreeResetMap = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shop = append(m.Shop, &ShopUnit{})
			if err := m.Shop[len(m.Shop)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraStrength", wireType)
			}
			m.ExtraStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtraStrength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hasten", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hasten == nil {
				m.Hasten = &Hasten{}
			}
			if err := m.Hasten.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedPoint = append(m.RedPoint, &RedPointUnit{})
			if err := m.RedPoint[len(m.RedPoint)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenWallReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenWallReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenWallReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenWallAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenWallAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenWallAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gold = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dead = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grids = append(m.Grids, &MapUnit{})
			if err := m.Grids[len(m.Grids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOver", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOver = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraStrength", wireType)
			}
			m.ExtraStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtraStrength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTreasureReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTreasureReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTreasureReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTreasureAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTreasureAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTreasureAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gold = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenTreasureReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenTreasureReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenTreasureReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenTreasureAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenTreasureAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenTreasureAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gold = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Grid == nil {
				m.Grid = &MapUnit{}
			}
			if err := m.Grid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Treasure", wireType)
			}
			m.Treasure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Treasure |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReviveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReviveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReviveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReviveAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReviveAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReviveAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dead = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Grid == nil {
				m.Grid = &MapUnit{}
			}
			if err := m.Grid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowX", wireType)
			}
			m.NowX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowX |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowY", wireType)
			}
			m.NowY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowY |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grids = append(m.Grids, &MapUnit{})
			if err := m.Grids[len(m.Grids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraStrength", wireType)
			}
			m.ExtraStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtraStrength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetMapReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetMapReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetMapReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetMapAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetMapAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetMapAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Maps == nil {
				m.Maps = &Maps{}
			}
			if err := m.Maps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeResetMap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FreeResetMap = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraStrength", wireType)
			}
			m.ExtraStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtraStrength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpLvReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpLvReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpLvReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpLvAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpLvAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpLvAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gold = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeResetMap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FreeResetMap = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StrengthNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StrengthNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StrengthNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraStrength", wireType)
			}
			m.ExtraStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtraStrength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomeNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomeNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomeNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gold = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomeType", wireType)
			}
			m.IncomeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IncomeType |= IncomeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiamondNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiamondNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiamondNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiamondType", wireType)
			}
			m.DiamondType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiamondType |= DiamondType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCMsg(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCMsg
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCMsg(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCMsg
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardUpLvReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardUpLvReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardUpLvReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumeType", wireType)
			}
			m.ConsumeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsumeType |= ConsumeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardUpLvAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardUpLvAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardUpLvAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShopUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShopUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopBuyType", wireType)
			}
			m.ShopBuyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopBuyType |= ShopType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyNum", wireType)
			}
			m.BuyNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopBuyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShopBuyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShopBuyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopBuyAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShopBuyAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShopBuyAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &ShopUnit{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraStrength", wireType)
			}
			m.ExtraStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtraStrength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HastenUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HastenUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HastenUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HastenType", wireType)
			}
			m.HastenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HastenType |= HastenType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Hasten) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hasten: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hasten: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hasten", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hasten = append(m.Hasten, &HastenUnit{})
			if err := m.Hasten[len(m.Hasten)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HastenReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HastenReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HastenReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HastenType", wireType)
			}
			m.HastenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HastenType |= HastenType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HastenAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HastenAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HastenAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hasten", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hasten == nil {
				m.Hasten = &HastenUnit{}
			}
			if err := m.Hasten.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InviteUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InviteUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InviteReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InviteReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InviteAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InviteAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Rewards = append(m.Rewards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCMsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCMsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Rewards) == 0 {
					m.Rewards = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Rewards = append(m.Rewards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invites = append(m.Invites, &InviteUnit{})
			if err := m.Invites[len(m.Invites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flag = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteRewardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InviteRewardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InviteRewardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteRewardAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InviteRewardAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InviteRewardAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InviteNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InviteNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invitees", wireType)
			}
			m.Invitees = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Invitees |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedPointUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedPointUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedPointUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPointType", wireType)
			}
			m.RedPointType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedPointType |= RedPointType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flag = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedPointReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedPointReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedPointReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPointType", wireType)
			}
			m.RedPointType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedPointType |= RedPointType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedPointAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedPointAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedPointAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedPoint == nil {
				m.RedPoint = &RedPointUnit{}
			}
			if err := m.RedPoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedPointNtf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedPointNtf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedPointNtf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedPoint = append(m.RedPoint, &RedPointUnit{})
			if err := m.RedPoint[len(m.RedPoint)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranking", wireType)
			}
			m.Ranking = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ranking |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gold = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankType", wireType)
			}
			m.RankType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankType |= RankType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RankAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RankAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RankAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankType", wireType)
			}
			m.RankType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankType |= RankType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &RankUnit{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Me", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Me == nil {
				m.Me = &RankUnit{}
			}
			if err := m.Me.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranking", wireType)
			}
			m.Ranking = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ranking |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			m.Member = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Member |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gold = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankType", wireType)
			}
			m.RankType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankType |= RankType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildListAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildListAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildListAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankType", wireType)
			}
			m.RankType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankType |= RankType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &GuildUnit{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildRankReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildRankReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildRankReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankType", wireType)
			}
			m.RankType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankType |= RankType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildRankAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildRankAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildRankAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankType", wireType)
			}
			m.RankType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankType |= RankType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &RankUnit{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildJoinReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildJoinReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildJoinReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildJoinAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildJoinAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildJoinAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildLeaveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildLeaveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildLeaveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildLeaveAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildLeaveAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildLeaveAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flag = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCMsg(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCMsg
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCMsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCMsg
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCMsg
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCMsg
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCMsg        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCMsg          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCMsg = fmt.Errorf("proto: unexpected end of group")
)
